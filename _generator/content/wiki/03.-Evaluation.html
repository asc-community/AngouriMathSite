<h2 class='centered'>Evaluation</h2><hr><p><a href='index.html'>&#8592; Back to the main page</a></p>Let us consider approaches to compute an expression.<br><br><h2>Evaluation</h2><br><br>All constant types, such as booleans and numbers, have their own types
in the AM's type hierarchy. When evaluating, you will also get a result 
in one of these types.<br><br>To evaluate an <text class='cw'>Entity</text> you need to call its method <text class='cw'>EvalNumerical</text> to
evaluate it into a <text class='cw'>Complex</text> and <text class='cw'>EvalBoolean</text> to evaluate it into a <text class='cw'>Boolean</text>.
Example:
<pre><code>Entity expr = "2 + 3";
Console.WriteLine(expr.EvalNumerical()); // 5
Entity expr2 = "true implies false";
Console.WriteLine(expr2.EvalBoolean()); // false</code></pre><br><br>If the given expression cannot be represented as the requested type, for example,
the result is a set, or the expression contains unresolved variables, exception
<text class='cw'>CannotEvalException</text>. Example:
<pre><code>Entity expr = "2 + 3 + a";
Console.WriteLine(expr.EvalNumerical()); // throws, as "a" is unknown
Entity expr2 = "{ 1, 3 }";
Console.WriteLine(expr2.EvalNumerical()); // throws, as the result is not a number
Entity expr3 = "true implies b";
Console.WriteLine(expr3.EvalBoolean()); // throws, as "b" is unknown</code></pre><br><br>Properties <text class='cw'>EvaluableBoolean</text> and <text class='cw'>EvaluableNumerical</text> show whether the expression
can be expressed as a single boolean or a single numerical value. For example,
do not call <text class='cw'>EvalNumerical()</text> if <text class='cw'>EvaluableNumerical</text> is false.<br><br>Once evaluated, the result might be converted to a privitive via explicit cast.
Example:
<pre><code>Entity expr = "3 / 5";
double evalDouble = (double)expr.EvalNumerical();
Console.WriteLine(evalDouble);
Complex evalComplex = (Complex)expr.EvalNumerical();
Console.WriteLine(evalComplex);
int evalInt = (int)expr.EvalNumerical();
Console.WriteLine(evalInt);</code></pre>
Output:
<pre><code>0.6
(0.6, 0)
0</code></pre>
If a number cannot be converted into the given primitive, a <text class='cw'>NumberCastException</text>
will be thrown. Example:
<pre><code>Entity expr = "3 / 5 + i";
double evalDouble = (double)expr.EvalNumerical(); // throws NumberCastException</code></pre><br><br>However, if you do not need the final number, but instead, the "most" evaluated
expresion, you may address property <text class='cw'>Evaled</text>. Example:
<pre><code>Entity expr = "2 + 3";
Console.WriteLine(expr.Evaled);
Entity expr2 = "2 + 3 + a";
Console.WriteLine(expr2.Evaled);</code></pre>
Output:
<pre><code>5
5 + a</code></pre><br><br>It is recommended to consider <text class='cw'>Evaled</text> as a free-to-access property. It is
a so-called <a href="https://habr.com/en/post/545936/">lazy property</a>.
Nonetheless, it should be pointed out that the first address of this property
executes computations and puts into cache.<br><br>Extensions: <text class='cw'>string.EvalNumerical()</text>, <text class='cw'>string.EvalBoolean()</text>.
