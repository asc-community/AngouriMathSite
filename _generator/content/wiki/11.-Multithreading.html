<h2 class='centered'>Multithreading</h2><hr><p><a href='index.html'>&#8592; Back to the main page</a></p>Here we will cover using AngouriMath in multithreaded systems and realtime software.<br><br><h2>Thread safety</h2><br><br>Immutability allows us to guarantee, that any operations with an expression is thread-safe. It is
also true that all methods and settings are thread-safe.<br><br>To add to it, there exists no method in AngouriMath which would create a new thread. All methods
are intentionally made single-threaded.<br><br><h2>Interruption of a method</h2><br><br>It is a known problem that sometimes you do not want to wait until a procedure finishes. Symbolic algebra
systems might take a while to execute the required command, not to mention bugs leading to infinite
executions. At this point, you are offered an ability to interrupt such methods as <text class='cw'>Limit</text>,
<text class='cw'>Simplify</text>, and <text class='cw'>Solve</text>.<br><br>Like it is classic for .NET, you need to create a <text class='cw'>CancellationToken</text> which will be then
read by those methods and checked for interruption. However, we wanted to make the API
as obvious and convenient as possible, and could not afford passing this token throughout
all methods in the library.<br><br>The solution is to set your token to a local threading context. We use <text class='cw'>AsyncLocal<T></text>
internally. Here is a sample code which shows how to interrupt a method:
<pre><code>var cancellationTokenSource = new CancellationTokenSource();<br><br>// That goes instead of passing your token to methods
MathS.Multithreading.SetLocalCancellationToken(
    cancellationTokenSource.Token);
    
// Then you normally run your task
var currTask = Task.Run(() => InputText.Text.Solve("x"),
    cancellationTokenSource.Token);
    
try
{
    await currTask;
    LabelState.Text = currTask.Result.ToString();
}
catch (OperationCanceledException)
{
    LabelState.Text = "Operation canceled";
}</code></pre>
