<h2 class="centered">Quick start</h2>
<hr>
You can start by installing the library or first investigating its functions.
<div class="centered">
    <a href="#installation">Installation</a> ∙
    <a href="#demos">Learn more and try online</a>
</div>
<br>

<a name="installation"></a>
<h3 class="centered">Installation</h3>
<hr>
<h3>Via NuGet for C# and F#</h3>
<p>
    <details><summary>How to install from NuGet?</summary>
    Here are a few instructions how to use NuGet:
    <ul>
    <li>
        <a href="https://docs.microsoft.com/en-us/nuget/quickstart/install-and-use-a-package-in-visual-studio">Visual Studio</a>
    </li>
    <li>
        <a href="https://www.jetbrains.com/help/rider/Using_NuGet.html#finding">JB Rider</a>
    </li>
    </ul>
    </details>
    <br>
    Packages you may want to install:
    <ul>
    <li>
        <a href="https://www.nuget.org/packages/AngouriMath">AngouriMath</a> (for C#)
    </li>
    <li>
        <a href="https://www.nuget.org/packages/AngouriMath.FSharp/">AngouriMath.FSharp</a> (for F# and C#)
    </li>
    </ul>

    AngouriMath targets <a href="https://docs.microsoft.com/en-us/dotnet/standard/net-standard">netstandard2.0</a>, which implies that it will work for almost any target.

    <br><br>
    <div class="attention importance">
        <b>IMPORTANT</b><br>
        It is recommended to include prereleases to install the last version, even if it is
        a pre-release one.
    </div>
</p>

<br>
<h3>Via NuGet for Interactive and Jupyter</h3>
<p>
    The package to install is here:
    <ul>
    <li>
        <a href="https://www.nuget.org/packages/AngouriMath.Interactive">AngouriMath.Interactive</a> (for Jupyter)
    </li>
    </ul>
    To install it, we recommend .NET Interactive's syntax, as follows:
    <pre><code>#r "nuget:AngouriMath.Interactive, *-*"
Interactive.magic();</code></pre>
    The second line binds the LaTeX rendering to <text class="cw">ILatexiseable</text>.
</p>

<br>
<h3>Via Git modules</h3>
<p>
    You may want to avoid using NuGet for your environment. Another reason, you do not want
    until a new version is released to try all the new features. Then you can use AngouriMath
    as a submodule for your git repository.
    <pre><code>git submodule add https://github.com/asc-community/AngouriMath</code></pre>
</p>
<br>
<h3>Hello, world!</h3>
<p>
    To verify you have everything installed correctly, let us write a simple program, computing
    a derivative:
    <h5>C# code:</h5>
    <pre><code>using AngouriMath;
using System;
Entity expr = "x + sin(y x)";
Console.WriteLine(expr);
Console.WriteLine(expr.Differentiate("x"));</code></pre>
    <h5>F# code:</h5>
    <pre><code>open Core
open Functions
let expr = parse "x + sin(y x)"
printf "%O" expr
printf "\n"
printf "%O" (differentiate "x" expr)</code></pre>
    <h5>Jupyter</h5>
    <pre><code>#r "nuget:AngouriMath.Interactive, *-*"
Interactive.magic();
open Core
open Functions
let expr = parse "x + sin(y x)"
differentiate "x" expr</code></pre>
</p>
<br>


<a name="demos"></a>
<h3 class="centered">Learn more with demos</h3>

<!--For mobiles-->
<div class="centered phone link-block-mob">
<a href="#parse">Parsing from string</a>
<a href="#eval">Evaluation</a>
<a href="#solver">Solving</a>
<a href="#calc">Calculus</a>
<a href="#bool">Boolean algebra</a>
<a href="#latex">LaTeX</a>
<a href="#compilation">Compilation</a> 
<a href="#inter">F# &amp; Jupyter</a>
<a href="#multi">Multithreading</a>
</div>
<!--End-->

<br>
<hr class="pc">
<div class="pc centered">
  <a href="#parse">Parsing from string</a>
∙ <a href="#eval">Evaluation</a>          
∙ <a href="#solver">Solving</a>           
∙ <a href="#calc">Calculus</a>            
∙ <a href="#latex">LaTeX</a>
<br><a href="#bool">Boolean algebra</a>     
∙ <a href="#compilation">Compilation</a>              
∙ <a href="#inter">F# &amp; Jupyter</a>   
∙ <a href="#multi">Multithreading</a>    
</div>
<hr class="pc">


<!--Parsing from string-->
<div class="block">

<h3 class="centered"><a name="parse" href="#parse" class="anchor">Parsing from string</a></h3>
<hr>
<p>
    AngouriMath allows to parse an expression from a string in runtime.
    Not only that, it allows to use some pretty syntax, for example,
    you may omit the multiplication operator or powers.
</p>
<p>
    Many
    mathematical objects may be parsed from a syntax which you normally
    write outside of algebra systems!
</p>
<details><summary>Try it here!</summary>
<iframe width="100%" height="300" src="https://dotnetfiddle.net/Widget/kvrlt2"
                                frameborder="0"></iframe>
</details>
</div>


<!--Evaluate &amp; Simplify-->
<div class="block">
<h3 class="centered"><a name="eval" href="#eval" class="anchor">Evaluate &amp; Simplify</a></h3>
<hr>
<p>
    Of course, you can evaluate expressions here to a number, boolean,
    or other types depending on your expression. As well as for many
    other functions, this is available as a method of Entity or
    as an extension.
</p>
<p>
    You can also simplify symbolic expressions even if they are not evaluable
    to a number. Just run the Simplify method. If you need a custom simplification
    criterion for the simplifier to follow (e. g. you hate complex numbers),
    you may set it in the runtime settings.
</p>
<details><summary>Try it here!</summary>
<iframe width="100%" height="460" src="https://dotnetfiddle.net/Widget/a7k6ck"
                                frameborder="0"></iframe>
								
</details>
</div>



<!--Solving equations-->
<div class="block">
<h3 class="centered"><a name="solver" href="#solver" class="anchor">Solving equations</a></h3>
<hr>
<p>
    AM allows to solve equations, inequalities, so-called statements,
    systems of equations, inequalities, unions of equations, etc.
    All you need to use it to know a fairly simple syntax.
</p>
<p>
    But first, let me define word Statement. We call a Statement an expression
    that is true for some values of variables, or false for some other.
    For example, "x + 2 > 0" is a Statement which is true for some x and false
    for others.
</p>
<details><summary>Try it here!</summary>
<iframe width="100%" height="375" src="https://dotnetfiddle.net/Widget/RxiAs7"
                                frameborder="0"></iframe>
</details>
</div>



<!--Differentiation, Integration, Limits-->
<div class="block">
<h3 class="centered"><a name="calc" href="#calc" class="anchor">Calculus</a></h3>
<hr>
<p>
    We can analytically find a derivative, integral, and limit over a variable.
</p>
<p>
    Integration and differentiation is performed via .Integrate and .Differentiate
    respectively, and the only argument is the variable.
</p>
<p>
    Limit takes the variable and the destination (where the variable tends),
    but it <i>might</i> also take the side from which the variable approaches
    the destination.
</p>
<details><summary>Try it here!</summary>
<iframe width="100%" height="400" src="https://dotnetfiddle.net/Widget/yvpsSx"
                                frameborder="0"></iframe>
</details>
</div>



<!--Boolean algebra-->
<div class="block">
<h3 class="centered"><a name="bool" href="#bool" class="anchor">Boolean algebra</a></h3>
<hr>
<p>
    As it could have been already noticed, you can work with boolean
    operators and variables in AngouriMath.
</p>
<p>
    Operators are similar to the syntax in python, such that
    "or", "and", "not". Also, there's "xor" and "implies".
</p>
<details><summary>Try it here!</summary>
<iframe width="100%" height="375" src="https://dotnetfiddle.net/Widget/tdgfGc"
                                frameborder="0"></iframe>
</details>
</div>



<!--LaTeX-->
<div class="block">
<h3 class="centered"><a name="latex" href="#latex" class="anchor">LaTeX</a></h3>
<hr>
<p>
    LaTeX is a popular format for mathematical formulas. For example,
    could be rendered like this:
    "\sqrt{x} + \int{\sin(x)}dx - \lim_{x \to 0}{y \over f(x)}"
    \[
    \sqrt{x} + \int{\sin(x)}dx - \lim_{x \to 0}{y \over f(x)}
    \]
</p>
<details><summary>Try it here!</summary>
<iframe width="100%" height="275" src="https://dotnetfiddle.net/Widget/V3Pk4s"
                                frameborder="0"></iframe>
</details>
</div>

<!--Compilation-->
<div class="block">
<h3 class="centered"><a name="compilation" href="#compilation" class="anchor">Compilation</a></h3>
<hr>
<p>
    With the version 1.3, you can compile expressions into native delegates. Not only that you
    can compile those with numerical types, but you can also compile them into predicates with the
    bool return type (if your expression involves conditions).
</p>
<details><summary>Try it here!</summary>
<iframe width="100%" height="275" src="https://dotnetfiddle.net/Widget/bZ5wkz"
                                frameborder="0"></iframe>
</details>
</div>


<!--F# &amp; Jupyter-->
<div class="block">
<h3 class="centered"><a name="inter" href="#inter" class="anchor">F# &amp; Jupyter</a></h3>
<hr>
<p>
    F# is a great functional language, which might be convenient for research and 
    scripting. Install AngouriMath.Interactive so that you can use it from both
    F# scripts and Jupyter Notebook.
</p>
<img src="https://github.com/asc-community/AngouriMath/raw/master/.github/additional/readme/interactive.PNG" width="100%">

<details><summary>Instruction</summary>
If you already installed <a href="https://jupyter.org/install">Jupyter</a> and 
<a href="https://github.com/dotnet/interactive/blob/main/docs/NotebooksLocalExperience.md">Interactive</a>
for it, install <a href="https://www.nuget.org/packages/AngouriMath.Interactive">package</a>
by copying this to your first cell:
<br>
<br>
<div class="code">
#r "nuget:AngouriMath.Interactive, *-*"
<br>
Interactive.magic();
</div>

</details>

</div>

<!--Multithreading-->
<div class="block">
<h3 class="centered"><a name="multi" href="#multi" class="anchor">Multithreading</a></h3>
<hr>
<p>
    You are guaranteed that all functions in AM run in one thread. It is also guaranteed that you can safely run multiple functions from AM in different threads, that is, all static variables and lazy properties are thread-safe.
</p>
<p>
    There is also support of cancellation a task. However, to avoid injecting the cancellation token argument into all methods, we use AsyncLocal<T> instead. That is why instead of passing your token to all methods what you need is to pass it once to the MathS Multithreading SetLocalCancellationToken (CancellationToken) method.
</p>
<details><summary>Example</summary>

<pre><code>var cancellationTokenSource = new CancellationTokenSource();

// That goes instead of passing your token to methods
MathS.Multithreading.SetLocalCancellationToken(
    cancellationTokenSource.Token);
    
// Then you normally run your task
var currTask = Task.Run(() => InputText.Text.Solve("x"),
    cancellationTokenSource.Token);
    
try
{
    await currTask;
    LabelState.Text = currTask.Result.ToString();
}
catch (OperationCanceledException)
{
    LabelState.Text = "Operation canceled";
}
</code></pre>

</details>
</div>