<h2 class="centered">AngouriMathExtensions</h2><hr/><p><a href="../AngouriMath.Extensions.html"><< Back to list of classes</a></p><p>Let us see all the members of the class or record AngouriMathExtensions</p><p><ul><li><p>Method Compile and its overloads</p><ul><li><p>Compile(System.String,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable)</p><p><summary>
            Compiles a given expression into a native lambda. We use the default protocol.
            If you plan using non-standard types, consider passing a compilation protocol
            </summary><param name="this">
            The object of which the method is called
            </param><typeparam name="TIn1">
            The type of the passed argument number 1
            </typeparam><typeparam name="TIn2">
            The type of the passed argument number 2
            </typeparam><typeparam name="TIn3">
            The type of the passed argument number 3
            </typeparam><typeparam name="TIn4">
            The type of the passed argument number 4
            </typeparam><typeparam name="TIn5">
            The type of the passed argument number 5
            </typeparam><typeparam name="TIn6">
            The type of the passed argument number 6
            </typeparam><typeparam name="TIn7">
            The type of the passed argument number 7
            </typeparam><typeparam name="TOut">
            The return type
            </typeparam><param name="var1">
            The variable corresponding to the function's argument number 1
            </param><param name="var2">
            The variable corresponding to the function's argument number 2
            </param><param name="var3">
            The variable corresponding to the function's argument number 3
            </param><param name="var4">
            The variable corresponding to the function's argument number 4
            </param><param name="var5">
            The variable corresponding to the function's argument number 5
            </param><param name="var6">
            The variable corresponding to the function's argument number 6
            </param><param name="var7">
            The variable corresponding to the function's argument number 7
            </param><returns>
            Returns a natively-compiled delegate
            </returns></p></li><li><p>Compile(System.String,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable)</p><p><summary>
            Compiles a given expression into a native lambda. We use the default protocol.
            If you plan using non-standard types, consider passing a compilation protocol
            </summary><param name="this">
            The object of which the method is called
            </param><typeparam name="TIn1">
            The type of the passed argument number 1
            </typeparam><typeparam name="TIn2">
            The type of the passed argument number 2
            </typeparam><typeparam name="TIn3">
            The type of the passed argument number 3
            </typeparam><typeparam name="TIn4">
            The type of the passed argument number 4
            </typeparam><typeparam name="TIn5">
            The type of the passed argument number 5
            </typeparam><typeparam name="TOut">
            The return type
            </typeparam><param name="var1">
            The variable corresponding to the function's argument number 1
            </param><param name="var2">
            The variable corresponding to the function's argument number 2
            </param><param name="var3">
            The variable corresponding to the function's argument number 3
            </param><param name="var4">
            The variable corresponding to the function's argument number 4
            </param><param name="var5">
            The variable corresponding to the function's argument number 5
            </param><returns>
            Returns a natively-compiled delegate
            </returns></p></li><li><p>Compile(System.String,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable)</p><p><summary>
            Compiles a given expression into a native lambda. We use the default protocol.
            If you plan using non-standard types, consider passing a compilation protocol
            </summary><param name="this">
            The object of which the method is called
            </param><typeparam name="TIn1">
            The type of the passed argument number 1
            </typeparam><typeparam name="TIn2">
            The type of the passed argument number 2
            </typeparam><typeparam name="TIn3">
            The type of the passed argument number 3
            </typeparam><typeparam name="TOut">
            The return type
            </typeparam><param name="var1">
            The variable corresponding to the function's argument number 1
            </param><param name="var2">
            The variable corresponding to the function's argument number 2
            </param><param name="var3">
            The variable corresponding to the function's argument number 3
            </param><returns>
            Returns a natively-compiled delegate
            </returns></p></li><li><p>Compile(System.String,AngouriMath.Entity.Variable)</p><p><summary>
            Compiles a given expression into a native lambda. We use the default protocol.
            If you plan using non-standard types, consider passing a compilation protocol
            </summary><param name="this">
            The object of which the method is called
            </param><typeparam name="TIn1">
            The type of the passed argument number 1
            </typeparam><typeparam name="TOut">
            The return type
            </typeparam><param name="var1">
            The variable corresponding to the function's argument number 1
            </param><returns>
            Returns a natively-compiled delegate
            </returns></p></li></ul></li><li><p>Method Derive(System.String,AngouriMath.Entity.Variable)</p><p><summary>
            Finds the symbolical derivative of the given expression
            </summary><param name="str">
            The expresion to be parsed and differentiated
            </param><param name="x">
            Over which variable to find the derivative
            </param><returns>
            The derived expression which might contain <see cref="T:AngouriMath.Entity.Derivativef" /> nodes,
            or the initial one
            </returns></p></li><li><p>Method EvalNumerical(System.String)</p><p><summary>
            Parses this and evals into a number by running <see cref="M:AngouriMath.Entity.EvalNumerical" /></summary><exception cref="T:AngouriMath.Core.Exceptions.CannotEvalException">
            This thrown when the given expression is boolean, tensoric, or contains variables.
            First, check whether it can be evaled: <see cref="P:AngouriMath.Entity.EvaluableNumerical" /></exception><returns>Collapses into one expression</returns></p></li><li><p>Method Expand(System.String)</p><p><summary>
            Parses and expands the given expression so that as many parentheses as possible
            get expanded into a linear expression.
            </summary><returns>An expanded expression</returns></p></li><li><p>Method Integrate(System.String,AngouriMath.Entity.Variable)</p><p><summary>
            Integrates the given expression over the `x` variable, if can.
            May return an unresolved <see cref="T:AngouriMath.Entity.Integralf" /> node.
            </summary><param name="str">
            The expression to be parsed and integrated over <paramref name="x" /></param><param name="x">Over which to integrate</param><returns>
            An integrated expression. It might remain the same,
            it might have no integrals, and it might be transformed so that
            only a few nodes have unresolved integrals.
            </returns></p></li><li><p>Method Latexise(System.String)</p><p><summary>
            Builds a LaTeX code from an expression
            </summary><returns>A <see cref="T:System.String" /> which can be rendered into pretty output</returns></p></li><li><p>Method Limit(System.String,AngouriMath.Entity.Variable,AngouriMath.Entity)</p><p><summary>
            Finds the limit of the given expression over the given variable
            </summary><param name="str">The expression to be parsed and whose limit to be found</param><param name="x">
            The variable to be approaching
            </param><param name="destination">
            A value where the variable approaches. It might be a symbolic
            expression, a finite number, or an infinite number, for example,
            "sqrt(x2 + x) / (3x + 3)".Limit("x", "+oo")
            </param><returns>
            A result or the <see cref="T:AngouriMath.Entity.Limitf" /> node if the limit
            cannot be determined
            </returns></p></li><li><p>Method MultiplyAll(System.Collections.Generic.IEnumerable{AngouriMath.Entity})</p><p><summary>
            Multiplies all the given terms and returns the resulting expression
            new Entity[]{ 1, 2, 3 }.MultiplyAll() -&gt; "1 * 2 * 3"
            </summary></p></li><li><p>Method Simplify(System.String)</p><p><summary>
            Parses this and simplifies by running <see cref="M:AngouriMath.Entity.Simplify(System.Int32)" /></summary><returns>Simplified expression</returns></p></li><li><p>Method Solve(System.String,AngouriMath.Entity.Variable)</p><p><summary>
            Solves the statement. The given expression must be boolean type,
            for example, equality, or boolean operators.
            </summary><param name="expr">The statement of <paramref name="var" /> that is assumed to be true</param><param name="var">The variables over which to solve</param><returns>A <see cref="T:AngouriMath.Entity.Set" /> of roots</returns></p></li><li><p>Method SolveSystem and its overloads</p><ul><li><p>SolveSystem(System.ValueTuple{System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.ValueTuple{System.String,System.String}},System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String)</p><p><summary>Solves a given set of arbitrary equations</summary><returns>A tensor whose width is 9 columns long or null if no solutions were found</returns></p></li><li><p>SolveSystem(System.ValueTuple{System.String,System.String,System.String,System.String,System.String,System.String,System.String},System.String,System.String,System.String,System.String,System.String,System.String,System.String)</p><p><summary>Solves a given set of arbitrary equations</summary><returns>A tensor whose width is 7 columns long or null if no solutions were found</returns></p></li><li><p>SolveSystem(System.ValueTuple{System.String,System.String,System.String,System.String,System.String},System.String,System.String,System.String,System.String,System.String)</p><p><summary>Solves a given set of arbitrary equations</summary><returns>A tensor whose width is 5 columns long or null if no solutions were found</returns></p></li><li><p>SolveSystem(System.ValueTuple{System.String,System.String,System.String},System.String,System.String,System.String)</p><p><summary>Solves a given set of arbitrary equations</summary><returns>A tensor whose width is 3 columns long or null if no solutions were found</returns></p></li></ul></li><li><p>Method Substitute(System.String,AngouriMath.Entity.Variable,AngouriMath.Entity)</p><p><summary>
            Subsitutes a variable by replacing all its occurances with the given value
            </summary><param name="expr">The expression where to substitute the variables</param><param name="var">A variable to substitute</param><param name="value">A value to substitute <paramref name="var" /></param><returns>Expression with substituted the variable</returns></p></li><li><p>Method ToEntity(System.String)</p><p><summary>
            Parses the expression into <see cref="T:AngouriMath.Entity" />.
            Synonymical to <see cref="M:AngouriMath.MathS.FromString(System.String)" /></summary><returns>Expression</returns></p></li><li><p>Method ToInterval and its overloads</p><ul><li><p>ToInterval(System.ValueTuple{System.Double,System.Boolean,System.Double,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.Double" /> and <see cref="T:System.Double" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.Double,System.Boolean,System.Int32,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.Double" /> and <see cref="T:System.Int32" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.Double,System.Boolean,System.Single,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.Double" /> and <see cref="T:System.Single" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.Double,System.Boolean,System.String,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.Double" /> and <see cref="T:System.String" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.Int32,System.Boolean,System.Double,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.Int32" /> and <see cref="T:System.Double" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.Int32,System.Boolean,System.Int32,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.Int32" /> and <see cref="T:System.Int32" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.Int32,System.Boolean,System.Single,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.Int32" /> and <see cref="T:System.Single" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.Int32,System.Boolean,System.String,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.Int32" /> and <see cref="T:System.String" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.Single,System.Boolean,System.Double,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.Single" /> and <see cref="T:System.Double" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.Single,System.Boolean,System.Int32,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.Single" /> and <see cref="T:System.Int32" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.Single,System.Boolean,System.Single,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.Single" /> and <see cref="T:System.Single" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.Single,System.Boolean,System.String,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.Single" /> and <see cref="T:System.String" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.String,System.Boolean,System.Double,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.String" /> and <see cref="T:System.Double" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.String,System.Boolean,System.Int32,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.String" /> and <see cref="T:System.Int32" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.String,System.Boolean,System.Single,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.String" /> and <see cref="T:System.Single" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.String,System.Boolean,System.String,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.String" /> and <see cref="T:System.String" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li></ul></li><li><p>Method ToNumber and its overloads</p><ul><li><p>ToNumber(System.Decimal)</p><p><summary>
            Converts an <see cref="T:System.Decimal" /> into an AM's understandable <see cref="T:AngouriMath.Entity.Number.Real" />
            which can be hung with others
            </summary><returns>AM's <see cref="T:AngouriMath.Entity.Number.Real" /></returns></p></li><li><p>ToNumber(System.Int64)</p><p><summary>
            Converts an <see cref="T:System.Int64" /> into an AM's understandable <see cref="T:AngouriMath.Entity.Number.Integer" />
            which can be hung with others
            </summary><returns>AM's <see cref="T:AngouriMath.Entity.Number.Integer" /></returns></p></li><li><p>ToNumber(System.Numerics.Complex)</p><p><summary>
            Converts Numerics's <see cref="T:System.Numerics.Complex" /> into an AM's understandable <see cref="T:AngouriMath.Entity.Number.Complex" />
            which can be hung with others
            </summary><returns>AM's <see cref="T:AngouriMath.Entity.Number.Complex" /></returns></p></li><li><p>ToNumber(System.Single)</p><p><summary>
            Converts an <see cref="T:System.Single" /> into an AM's understandable <see cref="T:AngouriMath.Entity.Number.Real" />
            which can be hung with others
            </summary><returns>AM's <see cref="T:AngouriMath.Entity.Number.Real" /></returns></p></li></ul></li><li><p>Method ToProvided(System.ValueTuple{AngouriMath.Entity,AngouriMath.Entity})</p><p><summary>
            Converts a tuple of an expression and its predicate to a 
            Provided node
            </summary><returns>Providedf node</returns></p></li><li><p>Method Unite(System.Collections.Generic.IEnumerable{AngouriMath.Entity.Set})</p><p><summary>
            Unites your <see cref="T:System.Collections.IEnumerable" /> into one <see cref="T:AngouriMath.Entity.Set" />.
            Applies the "or" operator on those nodes
            </summary><returns>A set of unique elements</returns></p></li></ul></p>