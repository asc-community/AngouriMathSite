<h2 class="centered">InternalAMExtensions</h2><hr/><p><a href="../AngouriMath.html"><< Back to list of classes</a></p><p>Let us see all the members of the class or record InternalAMExtensions</p><p><ul><li><p>Method AngouriMath.InternalAMExtensions.Arcsecant(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)</p><p><summary>
            sec(x) = value
            1 / cos(x) = value
            1 / value = cos(x)
            x = arccos(1 / value)
            </summary></p></li><li><p>Method AngouriMath.InternalAMExtensions.Arctan(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)</p><p><summary>Analogy of <see cref="M:System.Math.Atan(System.Double)" /></summary></p></li><li><p>Method AngouriMath.InternalAMExtensions.Arctan2(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)</p><p><summary>
            Analogy of <see cref="M:System.Math.Atan2(System.Double,System.Double)" /> for more see this
            <img src="http://i.imgur.com/TRLjs8R.png" /></summary></p></li><li><p>Method AngouriMath.InternalAMExtensions.CalculateSinFromCos(PeterO.Numbers.EDecimal,PeterO.Numbers.EDecimal,AngouriMath.InternalAMExtensions.ConstantCache,PeterO.Numbers.EContext)</p><p><summary>Helper function for calculating sin(x) from cos(x)</summary></p></li><li><p>Method AngouriMath.InternalAMExtensions.ConcatTuples``1(System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``0}})</p><p><summary>
            Concatenates 2-element tuples into an IEnumerable
            { (1, 2), (3, 4), (5, 6) } -&gt; { 1, 2, 3, 4, 5, 6 }
            </summary></p></li><li><p>Method AngouriMath.InternalAMExtensions.Cos(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)</p><p><summary>Analogy of <see cref="M:System.Math.Cos(System.Double)" /></summary></p></li><li><p>Method AngouriMath.InternalAMExtensions.Cosh(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)</p><p><summary>Analogy of <see cref="M:System.Math.Cosh(System.Double)" /></summary></p></li><li><p>Method AngouriMath.InternalAMExtensions.Factorial(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)</p><p><summary>
             Calculates the factorial of the specified <see cref="T:PeterO.Numbers.EDecimal" />.
            
             <para>This implementation uses
             <a href="https://en.wikipedia.org/wiki/Spouge%27s_approximation">Spouge's approximation</a>
             to calculate the factorial for non-integer values.</para><para>This involves calculating a series of constants that depend on the desired precision.
             Since this constant calculation is quite expensive (especially for higher precisions),
             the constants for a specific precision will be cached
             and subsequent calls to this method with the same precision will be much faster.</para><para>It is therefore recommended to do one call to this method with the standard precision of your application during the startup phase
             and to avoid calling it with many different precisions.</para><para>See: <a href="https://en.wikipedia.org/wiki/Factorial#Extension_of_factorial_to_non-integer_values_of_argument">Wikipedia: Factorial - Extension of factorial to non-integer values of argument</a></para></summary><param name="x">The <see cref="T:PeterO.Numbers.EDecimal" /></param><param name="mathContext">The <see cref="T:PeterO.Numbers.EContext" /> used for the result</param><returns>The factorial <see cref="T:PeterO.Numbers.EDecimal" /></returns><exception cref="T:System.ArgumentOutOfRangeException">Thrown when the precision of the <paramref name="mathContext" /> is outside the int32 range</exception><seealso cref="M:AngouriMath.InternalAMExtensions.Factorial(System.Int32)" /><seealso cref="M:AngouriMath.InternalAMExtensions.Gamma(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)" /></p></li><li><p>Method AngouriMath.InternalAMExtensions.Factorize(PeterO.Numbers.EInteger)</p><p><summary>
            Factorization of integer
            </summary></p></li><li><p>Method AngouriMath.InternalAMExtensions.Floor(PeterO.Numbers.EDecimal)</p><p><summary>If there is a fractional part, returns the previous largest integer</summary></p></li><li><p>Method AngouriMath.InternalAMExtensions.Lcm(PeterO.Numbers.EInteger,PeterO.Numbers.EInteger)</p><p><summary><a href="https://en.wikipedia.org/wiki/Least_common_multiple#Using_the_greatest_common_divisor" /></summary></p></li><li><p>Method AngouriMath.InternalAMExtensions.Phi(PeterO.Numbers.EInteger)</p><p><summary>
            Computes Euler phi function
            <a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function" /></summary>
            If integer x is non-positive, the result will be 0
        </p></li><li><p>Method AngouriMath.InternalAMExtensions.Round(PeterO.Numbers.EDecimal)</p><p><summary>Rounds half up to nearest integer</summary></p></li><li><p>Method AngouriMath.InternalAMExtensions.Secant(PeterO.Numbers.EDecimal,PeterO.Numbers.EContext)</p><p><summary>
            1 / Cos(x)
            </summary></p></li><li><p>Method AngouriMath.InternalAMExtensions.SplitDecimal(PeterO.Numbers.EDecimal)</p><p><summary>Splits decimal into integral part and fractional part.
            The fractional part is guaranteed to be positive.</summary></p></li><li><p>Method AngouriMath.InternalAMExtensions.TruncateToPeriodicInterval(PeterO.Numbers.EDecimal@,AngouriMath.InternalAMExtensions.ConstantCache,PeterO.Numbers.EContext)</p><p><summary>Truncates <paramref name="x" /> to [-2*<see cref="F:System.Math.PI" />, 2*<see cref="F:System.Math.PI" />] </summary></p></li></ul></p>