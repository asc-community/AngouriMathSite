<h2 class="yadg-h2 centered">MathS</h2><hr/><p class="yadg-p "><a href="../AngouriMath.html">&#8592; Back to list of classes</a></p><h3 class="yadg-h3 ">Description</h3><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Use functions from this class</div><h3 class="yadg-h3 ">Members</h3><p class="yadg-p "><ul class="yadg-ul "><li class="yadg-li yadg-member yadg-list"><a name='Abs'></a><p class="yadg-p "><h3 class="yadg-h3 ">Abs(AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>https://en.wikipedia.org/wiki/Absolute_value</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which Abs function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Abs node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Arccos'></a><p class="yadg-p "><h3 class="yadg-h3 ">Arccos(AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">https://en.wikipedia.org/wiki/Inverse_trigonometric_functions</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which arccosine will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Arccosine node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Arccosec'></a><p class="yadg-p "><h3 class="yadg-h3 ">Arccosec(AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">https://en.wikipedia.org/wiki/Inverse_trigonometric_functions</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which arccosecant will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Arcsine node with the reciprocal of the argument</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Arccotan'></a><p class="yadg-p "><h3 class="yadg-h3 ">Arccotan(AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">https://en.wikipedia.org/wiki/Inverse_trigonometric_functions</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which arccotangent will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Arccotangent node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Arcsec'></a><p class="yadg-p "><h3 class="yadg-h3 ">Arcsec(AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">https://en.wikipedia.org/wiki/Inverse_trigonometric_functions</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which arcsecant will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Arccosine node with the reciprocal of the argument</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Arcsin'></a><p class="yadg-p "><h3 class="yadg-h3 ">Arcsin(AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">https://en.wikipedia.org/wiki/Inverse_trigonometric_functions</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which arcsine will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Arcsine node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Arctan'></a><p class="yadg-p "><h3 class="yadg-h3 ">Arctan(AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">https://en.wikipedia.org/wiki/Inverse_trigonometric_functions</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which arctangent will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Arctangent node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Cbrt'></a><p class="yadg-p "><h3 class="yadg-h3 ">Cbrt(AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Special case of <a href="https://en.wikipedia.org/wiki/Power_function">https://en.wikipedia.org/wiki/Power_function</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">The argument of which cube root will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Power node with (1/3) as the power</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Conjunction'></a><p class="yadg-p "><h3 class="yadg-h3 ">Conjunction(AngouriMath.Entity, AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>https://en.wikipedia.org/wiki/Logical_conjunction</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Left argument node of which Conjunction function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "b"</strong></p><div class="yadg-div yadg-param">Right argument node of which Conjunction disjunction function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>And node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Cos'></a><p class="yadg-p "><h3 class="yadg-h3 ">Cos(AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Trigonometric_functions">https://en.wikipedia.org/wiki/Trigonometric_functions</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of cosine</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Cosine node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Cosec'></a><p class="yadg-p "><h3 class="yadg-h3 ">Cosec(AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Trigonometric_functions">https://en.wikipedia.org/wiki/Trigonometric_functions</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of cosecant</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Cosine node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Cotan'></a><p class="yadg-p "><h3 class="yadg-h3 ">Cotan(AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Trigonometric_functions">https://en.wikipedia.org/wiki/Trigonometric_functions</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which cotangent will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Cotangent node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Derivative'></a><p class="yadg-p "><h3 class="yadg-h3 ">Derivative</h3> Method and its overloads</p><ul class="yadg-ul "><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">Derivative(AngouriMath.Entity, AngouriMath.Entity, System.Int32)</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'            Hangs your <a href="../AngouriMath/Entity.html">Entity</a> to a derivative node<br>            (to evaluate instead use <a href="../AngouriMath.MathS/Compute.html#Derivative">Derivative(AngouriMath.Entity,AngouriMath.Entity.Variable)</a>)<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Parameter "expr"</strong></p><div class="yadg-div yadg-param">Expression to be hung</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "var"</strong></p><div class="yadg-div yadg-param">Variable over which derivative is taken</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "power"</strong></p><div class="yadg-div yadg-param">Number of times derivative is taken. Only integers will be simplified or evaluated.</div></p></li><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">Derivative(AngouriMath.Entity, AngouriMath.Entity)</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'            Hangs your <a href="../AngouriMath/Entity.html">Entity</a> to a derivative node<br>            (to evaluate instead use <a href="../AngouriMath.MathS/Compute.html#Derivative">Derivative(AngouriMath.Entity,AngouriMath.Entity.Variable)</a>)<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Parameter "expr"</strong></p><div class="yadg-div yadg-param">Expression to be hung</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "var"</strong></p><div class="yadg-div yadg-param">Variable over which derivative is taken</div></p></li></ul></li><li class="yadg-li yadg-member yadg-list"><a name='Disjunction'></a><p class="yadg-p "><h3 class="yadg-h3 ">Disjunction(AngouriMath.Entity, AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>https://en.wikipedia.org/wiki/Logical_disjunction</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">The left argument node of which Disjunction function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "b"</strong></p><div class="yadg-div yadg-param">The right argument node of which Disjunction function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Or node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='e'></a><p class="yadg-p "><h3 class="yadg-h3 ">e</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'            The e constant<br>            <a href="https://en.wikipedia.org/wiki/E_(mathematical_constant)">https://en.wikipedia.org/wiki/E_(mathematical_constant)</a></div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Equality'></a><p class="yadg-p "><h3 class="yadg-h3 ">Equality(AngouriMath.Entity, AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'            Do NOT confuse it with Equation<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Left argument node of which Equality function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "b"</strong></p><div class="yadg-div yadg-param">Right argument node of which Equality disjunction function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>An Equals node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Equations'></a><p class="yadg-p "><h3 class="yadg-h3 ">Equations</h3> Method and its overloads</p><ul class="yadg-ul "><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">Equations(AngouriMath.Entity[])</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Use it to solve equations</div><param name="equations"            An array of <a href="../AngouriMath/Entity.html">Entity</a> (or Strings)<br>            the system consists of<br>            </param><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>An EquationSystem which can then be solved</div></p></li><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">Equations(System.Collections.Generic.IEnumerable{AngouriMath.Entity})</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Use it to solve equations</div><param name="equations"            An array of <a href="../AngouriMath/Entity.html">Entity</a> (or Strings)<br>            the system consists of<br>            </param><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>An EquationSystem which can then be solved</div></p></li></ul></li><li class="yadg-li yadg-member yadg-list"><a name='ExclusiveDisjunction'></a><p class="yadg-p "><h3 class="yadg-h3 ">ExclusiveDisjunction(AngouriMath.Entity, AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>https://en.wikipedia.org/wiki/Exclusive_or#:~:text=Exclusive%20or%20or%20exclusive%20disjunction,⊕%2C%20↮%2C%20and%20≢.</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Left argument node of which Exclusive disjunction function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "b"</strong></p><div class="yadg-div yadg-param">Right argument node of which Exclusive disjunction function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Xor node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Factorial'></a><p class="yadg-p "><h3 class="yadg-h3 ">Factorial(AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Factorial">https://en.wikipedia.org/wiki/Factorial</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which factorial will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Factorial node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='FromBaseN'></a><p class="yadg-p "><h3 class="yadg-h3 ">FromBaseN(System.String, System.Int32)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Translates a number in base <paramref name="N"/> into base 10</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "num"</strong></p><div class="yadg-div yadg-param">A <a href="../AngouriMath.Entity.Number/Real.html">Real</a> in base <paramref name="N"/> to be translated into base 10</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "N"</strong></p><div class="yadg-div yadg-param">The base to translate the number from</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>The <a href="../AngouriMath.Entity.Number/Real.html">Real</a> in base 10</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='FromString'></a><p class="yadg-p "><h3 class="yadg-h3 ">FromString</h3> Method and its overloads</p><ul class="yadg-ul "><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">FromString(System.String, System.Boolean)</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Converts a String to an expression</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "expr"</strong></p><div class="yadg-div yadg-param">String expression, for example, <pre><code>"2 * x + 3 + sqrt(x)"</code></pre></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "useCache"</strong></p><div class="yadg-div yadg-param">By default is true, it boosts performance if you have multiple uses of the same string,<br>            for example, <br>            Entity expr = (Entity)"+oo" + "x".Limit("x", "+oo") * "+oo";<br>            First occurance will be parsed, others will be replaced with the cached entity<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>The parsed expression</div></p></li><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">FromString(System.String)</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Converts a String to an expression</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "expr"</strong></p><div class="yadg-div yadg-param">String expression, for example, <pre><code>"2 * x + 3 + sqrt(x)"</code></pre></div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>The parsed expression</div></p></li></ul></li><li class="yadg-li yadg-member yadg-list"><a name='Gamma'></a><p class="yadg-p "><h3 class="yadg-h3 ">Gamma(AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Gamma_function">https://en.wikipedia.org/wiki/Gamma_function</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which gamma function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Factorial node with one added to the argument</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='GreaterOrEqualThan'></a><p class="yadg-p "><h3 class="yadg-h3 ">GreaterOrEqualThan(AngouriMath.Entity, AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Left argument node of which the greter than or equal node will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "b"</strong></p><div class="yadg-div yadg-param">Right argument node of which the greater than or equal node function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>A node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='GreaterThan'></a><p class="yadg-p "><h3 class="yadg-h3 ">GreaterThan(AngouriMath.Entity, AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Left argument node of which the greater than node will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "b"</strong></p><div class="yadg-div yadg-param">Right argument node of which the greater than node function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>A node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='i'></a><p class="yadg-p "><h3 class="yadg-h3 ">i</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'            The imaginary one<br>            <a href="https://en.wikipedia.org/wiki/Imaginary_unit">https://en.wikipedia.org/wiki/Imaginary_unit</a></div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Implication'></a><p class="yadg-p "><h3 class="yadg-h3 ">Implication(AngouriMath.Entity, AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>https://en.wikipedia.org/wiki/Material_implication_(rule_of_inference)</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "assumption"</strong></p><div class="yadg-div yadg-param">The assumption node</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "conclusion"</strong></p><div class="yadg-div yadg-param">The conclusion node</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Implies node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Integral'></a><p class="yadg-p "><h3 class="yadg-h3 ">Integral</h3> Method and its overloads</p><ul class="yadg-ul "><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">Integral(AngouriMath.Entity, AngouriMath.Entity, System.Int32)</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'            Hangs your entity to an integral node<br>            (to evaluate instead use <a href="../AngouriMath.MathS/Compute.html#Integral">Integral(AngouriMath.Entity,AngouriMath.Entity.Variable)</a>)<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Parameter "expr"</strong></p><div class="yadg-div yadg-param">Expression to be hung</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "var"</strong></p><div class="yadg-div yadg-param">Variable over which integral is taken</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "power"</strong></p><div class="yadg-div yadg-param">Number of times integral is taken. Only integers will be simplified or evaluated.</div></p></li><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">Integral(AngouriMath.Entity, AngouriMath.Entity)</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'            Hangs your entity to an integral node<br>            (to evaluate instead use <a href="../AngouriMath.MathS/Compute.html#Integral">Integral(AngouriMath.Entity,AngouriMath.Entity.Variable)</a>)<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Parameter "expr"</strong></p><div class="yadg-div yadg-param">Expression to be hung</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "var"</strong></p><div class="yadg-div yadg-param">Variable over which integral is taken</div></p></li></ul></li><li class="yadg-li yadg-member yadg-list"><a name='Intersection'></a><p class="yadg-p "><h3 class="yadg-h3 ">Intersection(AngouriMath.Entity, AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Left argument node of which the intersection set node will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "b"</strong></p><div class="yadg-div yadg-param">Right argument node of which the intersection set node will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>A node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Latex'></a><p class="yadg-p "><h3 class="yadg-h3 ">Latex(AngouriMath.Core.ILatexiseable)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'            The <a href="https://en.wikipedia.org/wiki/LaTeX">LaTeX</a> representation of the argument<br>            </div><param name="latexiseable"            Any element (<a href="../AngouriMath/Entity.html">Entity</a>, <a href="../AngouriMath.Entity/Set.html">Set</a>, etc.) that can be represented in LaTeX<br>            </param></p></li><li class="yadg-li yadg-member yadg-list"><a name='LessOrEqualThan'></a><p class="yadg-p "><h3 class="yadg-h3 ">LessOrEqualThan(AngouriMath.Entity, AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Left argument node of which the less than or equal node will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "b"</strong></p><div class="yadg-div yadg-param">Right argument node of which the less than or equal node function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>A node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='LessThan'></a><p class="yadg-p "><h3 class="yadg-h3 ">LessThan(AngouriMath.Entity, AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Left argument node of which the less than node will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "b"</strong></p><div class="yadg-div yadg-param">Right argument node of which the less than node function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>A node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Limit'></a><p class="yadg-p "><h3 class="yadg-h3 ">Limit(AngouriMath.Entity, AngouriMath.Entity, AngouriMath.Entity, AngouriMath.Core.ApproachFrom)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'            Hangs your entity to a limit node<br>            (to evaluate instead use <a href="../AngouriMath.MathS/Compute.html#Limit">Limit(AngouriMath.Entity,AngouriMath.Entity.Variable,AngouriMath.Entity)</a>)<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Parameter "expr"</strong></p><div class="yadg-div yadg-param">Expression to be hung</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "var"</strong></p><div class="yadg-div yadg-param">Variable over which limit is taken</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "dest"</strong></p><div class="yadg-div yadg-param">Where <paramref name="var"/> approaches (could be finite or infinite)</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "approach"</strong></p><div class="yadg-div yadg-param">From where it approaches</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Ln'></a><p class="yadg-p "><h3 class="yadg-h3 ">Ln(AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'            Is a special case of logarithm where the base equals<br>            <a href="https://en.wikipedia.org/wiki/E_(mathematical_constant)">e</a>:<br>            <a href="https://en.wikipedia.org/wiki/Natural_logarithm">https://en.wikipedia.org/wiki/Natural_logarithm</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which natural logarithm will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Logarithm node with base equal to e</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Log'></a><p class="yadg-p "><h3 class="yadg-h3 ">Log</h3> Method and its overloads</p><ul class="yadg-ul "><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">Log(AngouriMath.Entity, AngouriMath.Entity)</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Logarithm">https://en.wikipedia.org/wiki/Logarithm</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "base"</strong></p><div class="yadg-div yadg-param">Base node of logarithm</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "x"</strong></p><div class="yadg-div yadg-param">Argument node of logarithm</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Logarithm node</div></p></li><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">Log(AngouriMath.Entity)</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Logarithm">https://en.wikipedia.org/wiki/Logarithm</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "x"</strong></p><div class="yadg-div yadg-param">Argument node of logarithm</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Logarithm node</div></p></li></ul></li><li class="yadg-li yadg-member yadg-list"><a name='NaN'></a><p class="yadg-p "><h3 class="yadg-h3 ">NaN</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'            That is both undefined and indeterminite<br>            Any operation on NaN returns NaN<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Negation'></a><p class="yadg-p "><h3 class="yadg-h3 ">Negation(AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>https://en.wikipedia.org/wiki/Negation</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which Negation function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>The Not node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='pi'></a><p class="yadg-p "><h3 class="yadg-h3 ">pi</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'            The pi constant<br>            <a href="https://en.wikipedia.org/wiki/Pi">https://en.wikipedia.org/wiki/Pi</a></div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Piecewise'></a><p class="yadg-p "><h3 class="yadg-h3 ">Piecewise</h3> Method and its overloads</p><ul class="yadg-ul "><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">Piecewise(System.Collections.Generic.IEnumerable{AngouriMath.Entity.Providedf}, AngouriMath.Entity)</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'            This is a piecewisely defined function, which turns into a particular definition<br>            once there exists a case number N such that case[N].Predicate is turned into true and<br>            for all i less than N : case[i].Predicate is turned into false.<br>            <br>            For example, Piecewise(new Providedf(a, b), new Providedf(d, false), new Providedf(f, true))<br>            will remain unchanged, because the first case is uncertain.<br>            <br>            Piecewise(new Providedf(a, false), new Providedf(d, false), new Providedf(f, true))<br>            will turn into f<br>            <br>            Piecewise(new Providedf(a, false), new Providedf(d, false), new Providedf(f, false))<br>            will turn into NaN<br>            </div><param name="cases"            Cases, each of type Provided.<br>            </param><param name="otherwise"            An otherwise case. Will be intepreted as otherwise.Provided(true). Optional.<br>            </param></p></li><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">Piecewise(System.ValueTuple{AngouriMath.Entity, AngouriMath.Entity}[])</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'            This is a piecewisely defined function, which turns into a particular definition<br>            once there exists a case number N such that case[N].Predicate is turned into true and<br>            for all i less than N : case[i].Predicate is turned into false.<br>            <br>            For example, Piecewise((a, b), (d, false), (f, true))<br>            will remain unchanged, because the first case is uncertain.<br>            <br>            Piecewise((a, false), (d, false), (f, true))<br>            will turn into f<br>            <br>            Piecewise((a, false), (d, false), (f, false))<br>            will turn into NaN<br>            </div><param name="cases"            Tuples of two expressions: an expression and a predicate<br>            </param></p></li></ul></li><li class="yadg-li yadg-member yadg-list"><a name='Pow'></a><p class="yadg-p "><h3 class="yadg-h3 ">Pow(AngouriMath.Entity, AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Power_function">https://en.wikipedia.org/wiki/Power_function</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "base"</strong></p><div class="yadg-div yadg-param">Base node of power</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "power"</strong></p><div class="yadg-div yadg-param">Argument node of power</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Power node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Provided'></a><p class="yadg-p "><h3 class="yadg-h3 ">Provided(AngouriMath.Entity, AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'            This will be turned into <paramref name="expression"/> if the <paramref name="condition"/> is true,<br>            into NaN if <paramref name="condition"/> is false, and remain the same otherwise<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Parameter "expression"</strong></p><div class="yadg-div yadg-param">The expression is extracted if the predicate is true</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "condition"</strong></p><div class="yadg-div yadg-param">Condition when the expression is defined</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>The Provided node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Sec'></a><p class="yadg-p "><h3 class="yadg-h3 ">Sec(AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Trigonometric_functions">https://en.wikipedia.org/wiki/Trigonometric_functions</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of secant</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Cosine node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='SetSubtraction'></a><p class="yadg-p "><h3 class="yadg-h3 ">SetSubtraction(AngouriMath.Entity, AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><param name="a"            Left argument node of which the set subtraction node will be taken<br>            That is, the resulting set of set subtraction is necessarily superset of this set<br>            </param><param name="b"            Right argument node of which the set subtraction set node will be taken<br>            That is, there is no element in the resulting set that belong to this one<br>            </param><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>A node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Signum'></a><p class="yadg-p "><h3 class="yadg-h3 ">Signum(AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>https://en.wikipedia.org/wiki/Sign_function</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which Signum function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Signum node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Sin'></a><p class="yadg-p "><h3 class="yadg-h3 ">Sin(AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Trigonometric_functions">https://en.wikipedia.org/wiki/Trigonometric_functions</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of sine</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Sine node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='SolveBooleanTable'></a><p class="yadg-p "><h3 class="yadg-h3 ">SolveBooleanTable(AngouriMath.Entity, AngouriMath.Entity.Variable[])</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'            Solves a boolean expression. That is, finds all values for<br>            <paramref name="variables"/> such that the expression turns into True when evaluated<br>            Uses a simple table of truth<br>            Use <a href="../AngouriMath/Entity.html#SolveBoolean">SolveBoolean(AngouriMath.Entity.Variable)</a> for smart solving<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='SolveEquation'></a><p class="yadg-p "><h3 class="yadg-h3 ">SolveEquation(AngouriMath.Entity, AngouriMath.Entity.Variable)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Solves one equation over one variable</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "equation"</strong></p><div class="yadg-div yadg-param">An equation that is assumed to equal 0</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "var"</strong></p><div class="yadg-div yadg-param">Variable whose values we are looking for</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>A <a href="../AngouriMath.Entity/Set.html">Set</a> of possible values or intervals of values</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Sqr'></a><p class="yadg-p "><h3 class="yadg-h3 ">Sqr(AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Special case of <a href="https://en.wikipedia.org/wiki/Power_function">https://en.wikipedia.org/wiki/Power_function</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument to be squared</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Power node with 2 as the power</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Sqrt'></a><p class="yadg-p "><h3 class="yadg-h3 ">Sqrt(AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Special case of <a href="https://en.wikipedia.org/wiki/Power_function">https://en.wikipedia.org/wiki/Power_function</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">The argument of which square root will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Power node with (1/2) as the power</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Tan'></a><p class="yadg-p "><h3 class="yadg-h3 ">Tan(AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Trigonometric_functions">https://en.wikipedia.org/wiki/Trigonometric_functions</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which tangent will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Tangent node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='ToBaseN'></a><p class="yadg-p "><h3 class="yadg-h3 ">ToBaseN(AngouriMath.Entity.Number.Real, System.Int32)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Translates a <a href="../AngouriMath.Entity/Number.html">Number</a> in base 10 into base <paramref name="N"/></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "num"</strong></p><div class="yadg-div yadg-param">A <a href="../AngouriMath.Entity.Number/Real.html">Real</a> in base 10 to be translated into base <paramref name="N"/></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "N"</strong></p><div class="yadg-div yadg-param">The base to translate the number into</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>A String with the number in the required base</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='ToSympyCode'></a><p class="yadg-p "><h3 class="yadg-h3 ">ToSympyCode(AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>sympy interpretable format</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "expr"</strong></p><div class="yadg-div yadg-param">An <a href="../AngouriMath/Entity.html">Entity</a> representing an expression</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='TryPolynomial'></a><p class="yadg-p "><h3 class="yadg-h3 ">TryPolynomial(AngouriMath.Entity, AngouriMath.Entity.Variable, AngouriMath.Entity@)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Returns an <a href="../AngouriMath/Entity.html">Entity</a> in polynomial order if possible</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "expr"</strong></p><div class="yadg-div yadg-param">The unordered <a href="../AngouriMath/Entity.html">Entity</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "variable"</strong></p><div class="yadg-div yadg-param">The variable of the polynomial</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "dst"</strong></p><div class="yadg-div yadg-param">The ordered result</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'><see langword="true"/> if success,<br>            <see langword="false"/> otherwise (<paramref name="dst"/> will be <see langword="null"/>)<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Union'></a><p class="yadg-p "><h3 class="yadg-h3 ">Union(AngouriMath.Entity, AngouriMath.Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Left argument node of which the union set node will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "b"</strong></p><div class="yadg-div yadg-param">Right argument node of which the union set node will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>A node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Var'></a><p class="yadg-p "><h3 class="yadg-h3 ">Var(System.String)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Creates an instance of <a href="../AngouriMath.Entity/Variable.html">Variable</a>.</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "name"</strong></p><div class="yadg-div yadg-param">The name of the <a href="../AngouriMath.Entity/Variable.html">Variable</a> which equality is based on.</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Variable node</div></p></li></ul></p>