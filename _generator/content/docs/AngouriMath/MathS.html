<h2 class="centered">MathS</h2><hr/><p><a href="../AngouriMath.html"><< Back to list of classes</a></p><p>Let us see all the members of the class or record MathS</p><p><ul><li><p>Method Arccos(AngouriMath.Entity)</p><p><summary><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions" /></summary><param name="a">Argument node of which arccosine will be taken</param><returns>Arccosine node</returns></p></li><li><p>Method Arccosec(AngouriMath.Entity)</p><p><summary><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions" /></summary><param name="a">Argument node of which arccosecant will be taken</param><returns>Arcsine node with the reciprocal of the argument</returns></p></li><li><p>Method Arccotan(AngouriMath.Entity)</p><p><summary><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions" /></summary><param name="a">Argument node of which arccotangent will be taken</param><returns>Arccotangent node</returns></p></li><li><p>Method Cos(AngouriMath.Entity)</p><p><summary><a href="https://en.wikipedia.org/wiki/Trigonometric_functions" /></summary><param name="a">Argument node of cosine</param><returns>Cosine node</returns></p></li><li><p>Method Cosec(AngouriMath.Entity)</p><p><summary><a href="https://en.wikipedia.org/wiki/Trigonometric_functions" /></summary><param name="a">Argument node of cosecant</param><returns>Cosine node</returns></p></li><li><p>Method Cotan(AngouriMath.Entity)</p><p><summary><a href="https://en.wikipedia.org/wiki/Trigonometric_functions" /></summary><param name="a">Argument node of which cotangent will be taken</param><returns>Cotangent node</returns></p></li><li><p>Method Derivative(AngouriMath.Entity,AngouriMath.Entity,System.Int32)</p><p><summary>
            Hangs your <see cref="T:AngouriMath.Entity" /> to a derivative node
            (to evaluate instead use <see cref="M:AngouriMath.MathS.Compute.Derivative(AngouriMath.Entity,AngouriMath.Entity.Variable)" />)
            </summary><param name="expr">Expression to be hung</param><param name="var">Variable over which derivative is taken</param><param name="power">Number of times derivative is taken. Only integers will be simplified or evaluated.</param></p></li><li><p>Method Disjunction(AngouriMath.Entity,AngouriMath.Entity)</p><p><summary>https://en.wikipedia.org/wiki/Logical_disjunction</summary><param name="a">The left argument node of which Disjunction function will be taken</param><param name="b">The right argument node of which Disjunction function will be taken</param><returns>Or node</returns></p></li><li><p>Method Equality(AngouriMath.Entity,AngouriMath.Entity)</p><p><summary>
            Do NOT confuse it with Equation
            </summary><param name="a">Left argument node of which Equality function will be taken</param><param name="b">Right argument node of which Equality disjunction function will be taken</param><returns>An Equals node</returns></p></li><li><p>Method Equations(System.Collections.Generic.IEnumerable{AngouriMath.Entity})</p><p><summary>Use it to solve equations</summary><param name="equations">
            An array of <see cref="T:AngouriMath.Entity" /> (or <see cref="T:System.String" />s)
            the system consists of
            </param><returns>An <see cref="T:AngouriMath.Core.EquationSystem" /> which can then be solved</returns></p></li><li><p>Method Factorial(AngouriMath.Entity)</p><p><summary><a href="https://en.wikipedia.org/wiki/Factorial" /></summary><param name="a">Argument node of which factorial will be taken</param><returns>Factorial node</returns></p></li><li><p>Method FromBaseN(System.String,System.Int32)</p><p><summary>Translates a number in base <paramref name="N" /> into base 10</summary><param name="num">A <see cref="T:AngouriMath.Entity.Number.Real" /> in base <paramref name="N" /> to be translated into base 10</param><param name="N">The base to translate the number from</param><returns>The <see cref="T:AngouriMath.Entity.Number.Real" /> in base 10</returns></p></li><li><p>Method FromString(System.String)</p><p><summary>Converts a <see cref="T:System.String" /> to an expression</summary><param name="expr"><see cref="T:System.String" /> expression, for example, <code>"2 * x + 3 + sqrt(x)"</code></param><returns>The parsed expression</returns></p></li><li><p>Method Implication(AngouriMath.Entity,AngouriMath.Entity)</p><p><summary>https://en.wikipedia.org/wiki/Material_implication_(rule_of_inference)</summary><param name="assumption">The assumption node</param><param name="conclusion">The conclusion node</param><returns>Implies node</returns></p></li><li><p>Method Integral(AngouriMath.Entity,AngouriMath.Entity,System.Int32)</p><p><summary>
            Hangs your entity to an integral node
            (to evaluate instead use <see cref="M:AngouriMath.MathS.Compute.Integral(AngouriMath.Entity,AngouriMath.Entity.Variable)" />)
            </summary><param name="expr">Expression to be hung</param><param name="var">Variable over which integral is taken</param><param name="power">Number of times integral is taken. Only integers will be simplified or evaluated.</param></p></li><li><p>Method Intersection(AngouriMath.Entity,AngouriMath.Entity)</p><p><param name="a">Left argument node of which the intersection set node will be taken</param><param name="b">Right argument node of which the intersection set node will be taken</param><returns>A node</returns></p></li><li><p>Method LessOrEqualThan(AngouriMath.Entity,AngouriMath.Entity)</p><p><param name="a">Left argument node of which the less than or equal node will be taken</param><param name="b">Right argument node of which the less than or equal node function will be taken</param><returns>A node</returns></p></li><li><p>Method LessThan(AngouriMath.Entity,AngouriMath.Entity)</p><p><param name="a">Left argument node of which the less than node will be taken</param><param name="b">Right argument node of which the less than node function will be taken</param><returns>A node</returns></p></li><li><p>Method Log(AngouriMath.Entity)</p><p><summary><a href="https://en.wikipedia.org/wiki/Logarithm" /></summary><param name="x">Argument node of logarithm</param><returns>Logarithm node</returns></p></li><li><p>Method Negation(AngouriMath.Entity)</p><p><summary>https://en.wikipedia.org/wiki/Negation</summary><param name="a">Argument node of which Negation function will be taken</param><returns>The Not node</returns></p></li><li><p>Method Piecewise(System.Collections.Generic.IEnumerable{AngouriMath.Entity.Providedf},AngouriMath.Entity)</p><p><summary>
            This is a piecewisely defined function, which turns into a particular definition
            once there exists a case number N such that case[N].Predicate is turned into true and
            for all i less than N : case[i].Predicate is turned into false.
            
            For example, Piecewise(new Providedf(a, b), new Providedf(d, false), new Providedf(f, true))
            will remain unchanged, because the first case is uncertain.
            
            Piecewise(new Providedf(a, false), new Providedf(d, false), new Providedf(f, true))
            will turn into f
            
            Piecewise(new Providedf(a, false), new Providedf(d, false), new Providedf(f, false))
            will turn into NaN
            </summary><param name="cases">
            Cases, each of type Provided.
            </param><param name="otherwise">
            An otherwise case. Will be intepreted as otherwise.Provided(true). Optional.
            </param></p></li><li><p>Method Signum(AngouriMath.Entity)</p><p><summary>https://en.wikipedia.org/wiki/Sign_function</summary><param name="a">Argument node of which Signum function will be taken</param><returns>Signum node</returns></p></li><li><p>Method SolveBooleanTable(AngouriMath.Entity,AngouriMath.Entity.Variable[])</p><p><summary>
            Solves a boolean expression. That is, finds all values for
            <paramref name="variables" /> such that the expression turns into True when evaluated
            Uses a simple table of truth
            Use <see cref="M:AngouriMath.Entity.SolveBoolean(AngouriMath.Entity.Variable)" /> for smart solving
            </summary></p></li><li><p>Method Sqr(AngouriMath.Entity)</p><p><summary>Special case of <a href="https://en.wikipedia.org/wiki/Power_function" /></summary><param name="a">Argument to be squared</param><returns>Power node with 2 as the power</returns></p></li><li><p>Method Sqrt(AngouriMath.Entity)</p><p><summary>Special case of <a href="https://en.wikipedia.org/wiki/Power_function" /></summary><param name="a">The argument of which square root will be taken</param><returns>Power node with (1/2) as the power</returns></p></li><li><p>Method ToSympyCode(AngouriMath.Entity)</p><p><returns>sympy interpretable format</returns><param name="expr">An <see cref="T:AngouriMath.Entity" /> representing an expression</param></p></li><li><p>Method Var(System.String)</p><p><summary>Creates an instance of <see cref="T:AngouriMath.Entity.Variable" />.</summary><param name="name">The name of the <see cref="T:AngouriMath.Entity.Variable" /> which equality is based on.</param><returns>Variable node</returns></p></li></ul></p>