<h2 class="yadg-h2 centered">Complex</h2><hr/><p class="yadg-p "><a href="../AngouriMath.Entity.Number.html">&#8592; Back to list of classes</a></p><h3 class="yadg-h3 ">Description</h3><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Extension for <a href="../AngouriMath.Entity.Number/Real.html">Real</a><a href="https://en.wikipedia.org/wiki/Complex_number">https://en.wikipedia.org/wiki/Complex_number</a></div><h3 class="yadg-h3 ">Members</h3><p class="yadg-p "><ul class="yadg-ul "><li class="yadg-li yadg-member yadg-list"><a name='#ctor'></a><p class="yadg-p "><h3 class="yadg-h3 ">#ctor(AngouriMath.Entity.Number.Real, AngouriMath.Entity.Number.Real)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Constructor does not downcast automatically. Use <a href="../AngouriMath.Entity.Number/Complex.html#Create">Create(AngouriMath.Entity.Number.Real,AngouriMath.Entity.Number.Real)</a> for automatic downcasting<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Abs'></a><p class="yadg-p "><h3 class="yadg-h3 ">Abs</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>The magnitude of this <a href="../AngouriMath.Entity.Number/Complex.html">Complex</a>.</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>            Returns the absolute value of this complex number, to be precise,<br>            if this = a + ib, this.Abs() -&gt; sqrt(a^2 + b^2)<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Codomain'></a><p class="yadg-p "><h3 class="yadg-h3 ">Codomain</h3> Property</p><p class="yadg-p "><inheritdoc /></p></li><li class="yadg-li yadg-member yadg-list"><a name='Conjugate'></a><p class="yadg-p "><h3 class="yadg-h3 ">Conjugate</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Returns conjugate of a complex number. Given this = a + ib, Conjugate() -&gt; a - ib</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Conjugate of the number</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Create'></a><p class="yadg-p "><h3 class="yadg-h3 ">Create</h3> Method and its overloads</p><ul class="yadg-ul "><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">Create(AngouriMath.Entity.Number.Real, AngouriMath.Entity.Number.Real)</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Creates an instance of Complex<br>            </div></p></li><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">Create(PeterO.Numbers.EDecimal, PeterO.Numbers.EDecimal)</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Creates an instance of Complex<br>            </div></p></li></ul></li><li class="yadg-li yadg-member yadg-list"><a name='CreatePolar'></a><p class="yadg-p "><h3 class="yadg-h3 ">CreatePolar(PeterO.Numbers.EDecimal, PeterO.Numbers.EDecimal)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Creates a normal complex from its polar representation<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Deconstruct'></a><p class="yadg-p "><h3 class="yadg-h3 ">Deconstruct(AngouriMath.Entity.Number.Real@, AngouriMath.Entity.Number.Real@)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Deconstructs as record<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='ImaginaryOne'></a><p class="yadg-p "><h3 class="yadg-h3 ">ImaginaryOne</h3> Field</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            An imaginary one. You can use it to avoid allocations<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='ImaginaryPart'></a><p class="yadg-p "><h3 class="yadg-h3 ">ImaginaryPart</h3> Property</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Imaginary part of a complex number<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='IsExact'></a><p class="yadg-p "><h3 class="yadg-h3 ">IsExact</h3> Property</p><p class="yadg-p "><inheritdoc /></p></li><li class="yadg-li yadg-member yadg-list"><a name='IsNaN'></a><p class="yadg-p "><h3 class="yadg-h3 ">IsNaN</h3> Property</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Checks whether the given number is undefined<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='IsZero'></a><p class="yadg-p "><h3 class="yadg-h3 ">IsZero</h3> Property</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Checks if both parts equal 0<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Latexise'></a><p class="yadg-p "><h3 class="yadg-h3 ">Latexise</h3> Method</p><p class="yadg-p "><inheritdoc /></p></li><li class="yadg-li yadg-member yadg-list"><a name='MinusImaginaryOne'></a><p class="yadg-p "><h3 class="yadg-h3 ">MinusImaginaryOne</h3> Field</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            An imaginary minus one. You can use it to avoid allocations<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='NegNegInfinity'></a><p class="yadg-p "><h3 class="yadg-h3 ">NegNegInfinity</h3> Field</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>-oo + -ooi</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='NegPosInfinity'></a><p class="yadg-p "><h3 class="yadg-h3 ">NegPosInfinity</h3> Field</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>-oo + +ooi</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Parse'></a><p class="yadg-p "><h3 class="yadg-h3 ">Parse(System.String)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Parses a String into <a href="../AngouriMath.Entity.Number/Complex.html">Complex</a></div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'><a href="../AngouriMath.Entity.Number/Complex.html">Complex</a></div><exception cref="T:AngouriMath.Core.Exceptions.ParseException">Thrown when <paramref name="source"/> cannot be parsed.</exception></p></li><li class="yadg-li yadg-member yadg-list"><a name='Phase'></a><p class="yadg-p "><h3 class="yadg-h3 ">Phase</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            The phase of a complex number (aka angle)<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='PosNegInfinity'></a><p class="yadg-p "><h3 class="yadg-h3 ">PosNegInfinity</h3> Field</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>+oo + -ooi</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='PosPosInfinity'></a><p class="yadg-p "><h3 class="yadg-h3 ">PosPosInfinity</h3> Field</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>+oo + +ooi</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='RealPart'></a><p class="yadg-p "><h3 class="yadg-h3 ">RealPart</h3> Property</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Real part of a complex number<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Stringize'></a><p class="yadg-p "><h3 class="yadg-h3 ">Stringize</h3> Method</p><p class="yadg-p "><inheritdoc /></p></li><li class="yadg-li yadg-member yadg-list"><a name='ThisIsFinite'></a><p class="yadg-p "><h3 class="yadg-h3 ">ThisIsFinite</h3> Property</p><p class="yadg-p "><inheritdoc /></p></li><li class="yadg-li yadg-member yadg-list"><a name='ToNumerics'></a><p class="yadg-p "><h3 class="yadg-h3 ">ToNumerics</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Convers the Complex to its of the system module Numerics<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='ToString'></a><p class="yadg-p "><h3 class="yadg-h3 ">ToString</h3> Method</p><p class="yadg-p "><inheritdoc /></p></li><li class="yadg-li yadg-member yadg-list"><a name='TryParse'></a><p class="yadg-p "><h3 class="yadg-h3 ">TryParse(System.String, AngouriMath.Entity.Number.Complex@)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Tries to parse a <a href="../AngouriMath.Entity.Number/Complex.html">Complex</a> from String</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "source"</strong></p><div class="yadg-div yadg-param"></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "dst"</strong></p><div class="yadg-div yadg-param">            The result will be written to this variable only if parsing was successful,<br>            if it was not, do not access this variable<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>If parsing was successful - <see langword="true"/>, <see langword="false"/> otherwise</div></p></li></ul></p>