<!doctype html>
<html lang="en">
<head>
    <title>AngouriMath</title>    
    <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon">
	<link rel="stylesheet" href="../../styles.css">
    <link rel="stylesheet" href="../../themes.css">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Overpass+Mono">
    <!-- Yandex.Metrika counter -->
<script type="text/javascript" >
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

   ym(72666283, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true
   });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/72666283" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<script src="https://buttons.github.io/buttons.js"></script>
</head>

<body>


<div class="nav-left pc">
<div class="centered nav-top">
<div>

<div class="centered">
<img class="logo pc" src="../../img/icon_cropped.png" width="120wh" height="120wh"/>
</div>

<h3>AngouriMath</h3>
<p class="slogan pc" style="color: gray">Symbolics for .NET</p>
</div>
<br>
</div>

<h5>Table of contents</h5>
<ul>
    <li><!--active_--><a href="/">Home page</a>                                              </li>
    <li><!--active_quickstart--><a href="/quickstart">Quick start</a>                                                    </li>
    <li><!--active_docs--><a href="/docs/namespaces.html">Documentation</a>                                                    </li>
    <li><!--active_whatsnew--><a href="/whatsnew">What's new</a>                                                    </li>
    <li><!--active_demo--><a href="/demo">Try online</a>                                                               </li>
    <li><!--active_why--><a href="/why">Where can be used</a>                                                                </li>
    <li><a href="https://github.com/asc-community/AngouriMath" target="_blank">GitHub repository</a>     </li>
    <li><a href="https://github.com/asc-community/AngouriMath/issues/new/choose" target="_blank">Report a bug</a></li>
    <li><a href="https://www.patreon.com/AngouriMath" target="_blank">Donate</a></li>
    <li><a href="/#contacts">Contacts</a>    </li>
</ul>

</div>

<div class="main">
<div class="head-of-page">

<!--Head of page for mobiles-->
<div class="centered phone">
<img class="logo" src="../../img/icon_cropped.png" width="100wh"/>
<h2>AngouriMath</h2>
</div>
<!--End-->

<!--For mobiles-->
<details class="phone"><summary>Navigation</summary>
<div class="centered link-block-mob">
<a href="/">Home</a>
<a href="/quickstart">Quick start</a>
<a href="/docs/namespaces.html">Documentation</a>
<a href="/whatsnew">What's new</a>
<a href="/demo">Try</a>
<a href="/why">Use</a>
<a href="https://angouri.org" target="_blank">Angouri.org</a>
<a href="https://github.com/asc-community/AngouriMath" target="_blank">GitHub</a>
<a href="https://github.com/asc-community/AngouriMath/issues/new/choose" target="_blank">Report a bug</a>
<a href="https://www.patreon.com/AngouriMath" target="_blank">Donate</a>
<a href="/#contacts">Contacts</a>
</div>
</details>
<!--End-->

</div>

<!--Top end-->

<h2 class="centered">AngouriMathExtensions</h2><hr/><p><a href="../AngouriMath.Extensions.html"><< Back to list of classes</a></p><p>Let us see all the members of the class or record AngouriMathExtensions</p><p><ul><li><p>Method Compile and its overloads</p><ul><li><p>Compile(System.String,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable)</p><p><summary>
            Compiles a given expression into a native lambda. We use the default protocol.
            If you plan using non-standard types, consider passing a compilation protocol
            </summary><param name="this">
            The object of which the method is called
            </param><typeparam name="TIn1">
            The type of the passed argument number 1
            </typeparam><typeparam name="TIn2">
            The type of the passed argument number 2
            </typeparam><typeparam name="TIn3">
            The type of the passed argument number 3
            </typeparam><typeparam name="TIn4">
            The type of the passed argument number 4
            </typeparam><typeparam name="TIn5">
            The type of the passed argument number 5
            </typeparam><typeparam name="TIn6">
            The type of the passed argument number 6
            </typeparam><typeparam name="TIn7">
            The type of the passed argument number 7
            </typeparam><typeparam name="TOut">
            The return type
            </typeparam><param name="var1">
            The variable corresponding to the function's argument number 1
            </param><param name="var2">
            The variable corresponding to the function's argument number 2
            </param><param name="var3">
            The variable corresponding to the function's argument number 3
            </param><param name="var4">
            The variable corresponding to the function's argument number 4
            </param><param name="var5">
            The variable corresponding to the function's argument number 5
            </param><param name="var6">
            The variable corresponding to the function's argument number 6
            </param><param name="var7">
            The variable corresponding to the function's argument number 7
            </param><returns>
            Returns a natively-compiled delegate
            </returns></p></li><li><p>Compile(System.String,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable)</p><p><summary>
            Compiles a given expression into a native lambda. We use the default protocol.
            If you plan using non-standard types, consider passing a compilation protocol
            </summary><param name="this">
            The object of which the method is called
            </param><typeparam name="TIn1">
            The type of the passed argument number 1
            </typeparam><typeparam name="TIn2">
            The type of the passed argument number 2
            </typeparam><typeparam name="TIn3">
            The type of the passed argument number 3
            </typeparam><typeparam name="TIn4">
            The type of the passed argument number 4
            </typeparam><typeparam name="TIn5">
            The type of the passed argument number 5
            </typeparam><typeparam name="TOut">
            The return type
            </typeparam><param name="var1">
            The variable corresponding to the function's argument number 1
            </param><param name="var2">
            The variable corresponding to the function's argument number 2
            </param><param name="var3">
            The variable corresponding to the function's argument number 3
            </param><param name="var4">
            The variable corresponding to the function's argument number 4
            </param><param name="var5">
            The variable corresponding to the function's argument number 5
            </param><returns>
            Returns a natively-compiled delegate
            </returns></p></li><li><p>Compile(System.String,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable,AngouriMath.Entity.Variable)</p><p><summary>
            Compiles a given expression into a native lambda. We use the default protocol.
            If you plan using non-standard types, consider passing a compilation protocol
            </summary><param name="this">
            The object of which the method is called
            </param><typeparam name="TIn1">
            The type of the passed argument number 1
            </typeparam><typeparam name="TIn2">
            The type of the passed argument number 2
            </typeparam><typeparam name="TIn3">
            The type of the passed argument number 3
            </typeparam><typeparam name="TOut">
            The return type
            </typeparam><param name="var1">
            The variable corresponding to the function's argument number 1
            </param><param name="var2">
            The variable corresponding to the function's argument number 2
            </param><param name="var3">
            The variable corresponding to the function's argument number 3
            </param><returns>
            Returns a natively-compiled delegate
            </returns></p></li><li><p>Compile(System.String,AngouriMath.Entity.Variable)</p><p><summary>
            Compiles a given expression into a native lambda. We use the default protocol.
            If you plan using non-standard types, consider passing a compilation protocol
            </summary><param name="this">
            The object of which the method is called
            </param><typeparam name="TIn1">
            The type of the passed argument number 1
            </typeparam><typeparam name="TOut">
            The return type
            </typeparam><param name="var1">
            The variable corresponding to the function's argument number 1
            </param><returns>
            Returns a natively-compiled delegate
            </returns></p></li></ul></li><li><p>Method Derive(System.String,AngouriMath.Entity.Variable)</p><p><summary>
            Finds the symbolical derivative of the given expression
            </summary><param name="str">
            The expresion to be parsed and differentiated
            </param><param name="x">
            Over which variable to find the derivative
            </param><returns>
            The derived expression which might contain <see cref="T:AngouriMath.Entity.Derivativef" /> nodes,
            or the initial one
            </returns></p></li><li><p>Method EvalNumerical(System.String)</p><p><summary>
            Parses this and evals into a number by running <see cref="M:AngouriMath.Entity.EvalNumerical" /></summary><exception cref="T:AngouriMath.Core.Exceptions.CannotEvalException">
            This thrown when the given expression is boolean, tensoric, or contains variables.
            First, check whether it can be evaled: <see cref="P:AngouriMath.Entity.EvaluableNumerical" /></exception><returns>Collapses into one expression</returns></p></li><li><p>Method Expand(System.String)</p><p><summary>
            Parses and expands the given expression so that as many parentheses as possible
            get expanded into a linear expression.
            </summary><returns>An expanded expression</returns></p></li><li><p>Method Integrate(System.String,AngouriMath.Entity.Variable)</p><p><summary>
            Integrates the given expression over the `x` variable, if can.
            May return an unresolved <see cref="T:AngouriMath.Entity.Integralf" /> node.
            </summary><param name="str">
            The expression to be parsed and integrated over <paramref name="x" /></param><param name="x">Over which to integrate</param><returns>
            An integrated expression. It might remain the same,
            it might have no integrals, and it might be transformed so that
            only a few nodes have unresolved integrals.
            </returns></p></li><li><p>Method Latexise(System.String)</p><p><summary>
            Builds a LaTeX code from an expression
            </summary><returns>A <see cref="T:System.String" /> which can be rendered into pretty output</returns></p></li><li><p>Method Limit(System.String,AngouriMath.Entity.Variable,AngouriMath.Entity)</p><p><summary>
            Finds the limit of the given expression over the given variable
            </summary><param name="str">The expression to be parsed and whose limit to be found</param><param name="x">
            The variable to be approaching
            </param><param name="destination">
            A value where the variable approaches. It might be a symbolic
            expression, a finite number, or an infinite number, for example,
            "sqrt(x2 + x) / (3x + 3)".Limit("x", "+oo")
            </param><returns>
            A result or the <see cref="T:AngouriMath.Entity.Limitf" /> node if the limit
            cannot be determined
            </returns></p></li><li><p>Method MultiplyAll(System.Collections.Generic.IEnumerable{AngouriMath.Entity})</p><p><summary>
            Multiplies all the given terms and returns the resulting expression
            new Entity[]{ 1, 2, 3 }.MultiplyAll() -&gt; "1 * 2 * 3"
            </summary></p></li><li><p>Method Simplify(System.String)</p><p><summary>
            Parses this and simplifies by running <see cref="M:AngouriMath.Entity.Simplify(System.Int32)" /></summary><returns>Simplified expression</returns></p></li><li><p>Method Solve(System.String,AngouriMath.Entity.Variable)</p><p><summary>
            Solves the statement. The given expression must be boolean type,
            for example, equality, or boolean operators.
            </summary><param name="expr">The statement of <paramref name="var" /> that is assumed to be true</param><param name="var">The variables over which to solve</param><returns>A <see cref="T:AngouriMath.Entity.Set" /> of roots</returns></p></li><li><p>Method SolveSystem and its overloads</p><ul><li><p>SolveSystem(System.ValueTuple{System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.ValueTuple{System.String,System.String}},System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String,System.String)</p><p><summary>Solves a given set of arbitrary equations</summary><returns>A tensor whose width is 9 columns long or null if no solutions were found</returns></p></li><li><p>SolveSystem(System.ValueTuple{System.String,System.String,System.String,System.String,System.String,System.String,System.String},System.String,System.String,System.String,System.String,System.String,System.String,System.String)</p><p><summary>Solves a given set of arbitrary equations</summary><returns>A tensor whose width is 7 columns long or null if no solutions were found</returns></p></li><li><p>SolveSystem(System.ValueTuple{System.String,System.String,System.String,System.String,System.String},System.String,System.String,System.String,System.String,System.String)</p><p><summary>Solves a given set of arbitrary equations</summary><returns>A tensor whose width is 5 columns long or null if no solutions were found</returns></p></li><li><p>SolveSystem(System.ValueTuple{System.String,System.String,System.String},System.String,System.String,System.String)</p><p><summary>Solves a given set of arbitrary equations</summary><returns>A tensor whose width is 3 columns long or null if no solutions were found</returns></p></li></ul></li><li><p>Method Substitute(System.String,AngouriMath.Entity.Variable,AngouriMath.Entity)</p><p><summary>
            Subsitutes a variable by replacing all its occurances with the given value
            </summary><param name="expr">The expression where to substitute the variables</param><param name="var">A variable to substitute</param><param name="value">A value to substitute <paramref name="var" /></param><returns>Expression with substituted the variable</returns></p></li><li><p>Method ToEntity(System.String)</p><p><summary>
            Parses the expression into <see cref="T:AngouriMath.Entity" />.
            Synonymical to <see cref="M:AngouriMath.MathS.FromString(System.String)" /></summary><returns>Expression</returns></p></li><li><p>Method ToInterval and its overloads</p><ul><li><p>ToInterval(System.ValueTuple{System.Double,System.Boolean,System.Double,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.Double" /> and <see cref="T:System.Double" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.Double,System.Boolean,System.Int32,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.Double" /> and <see cref="T:System.Int32" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.Double,System.Boolean,System.Single,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.Double" /> and <see cref="T:System.Single" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.Double,System.Boolean,System.String,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.Double" /> and <see cref="T:System.String" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.Int32,System.Boolean,System.Double,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.Int32" /> and <see cref="T:System.Double" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.Int32,System.Boolean,System.Int32,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.Int32" /> and <see cref="T:System.Int32" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.Int32,System.Boolean,System.Single,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.Int32" /> and <see cref="T:System.Single" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.Int32,System.Boolean,System.String,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.Int32" /> and <see cref="T:System.String" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.Single,System.Boolean,System.Double,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.Single" /> and <see cref="T:System.Double" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.Single,System.Boolean,System.Int32,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.Single" /> and <see cref="T:System.Int32" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.Single,System.Boolean,System.Single,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.Single" /> and <see cref="T:System.Single" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.Single,System.Boolean,System.String,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.Single" /> and <see cref="T:System.String" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.String,System.Boolean,System.Double,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.String" /> and <see cref="T:System.Double" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.String,System.Boolean,System.Int32,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.String" /> and <see cref="T:System.Int32" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.String,System.Boolean,System.Single,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.String" /> and <see cref="T:System.Single" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li><li><p>ToInterval(System.ValueTuple{System.String,System.Boolean,System.String,System.Boolean})</p><p><summary>
            Takes a <see cref="T:System.String" /> and <see cref="T:System.String" /> and returns
            a closed interval (so that left and right ends are included)
            </summary><returns>Interval</returns></p></li></ul></li><li><p>Method ToNumber and its overloads</p><ul><li><p>ToNumber(System.Decimal)</p><p><summary>
            Converts an <see cref="T:System.Decimal" /> into an AM's understandable <see cref="T:AngouriMath.Entity.Number.Real" />
            which can be hung with others
            </summary><returns>AM's <see cref="T:AngouriMath.Entity.Number.Real" /></returns></p></li><li><p>ToNumber(System.Int64)</p><p><summary>
            Converts an <see cref="T:System.Int64" /> into an AM's understandable <see cref="T:AngouriMath.Entity.Number.Integer" />
            which can be hung with others
            </summary><returns>AM's <see cref="T:AngouriMath.Entity.Number.Integer" /></returns></p></li><li><p>ToNumber(System.Numerics.Complex)</p><p><summary>
            Converts Numerics's <see cref="T:System.Numerics.Complex" /> into an AM's understandable <see cref="T:AngouriMath.Entity.Number.Complex" />
            which can be hung with others
            </summary><returns>AM's <see cref="T:AngouriMath.Entity.Number.Complex" /></returns></p></li><li><p>ToNumber(System.Single)</p><p><summary>
            Converts an <see cref="T:System.Single" /> into an AM's understandable <see cref="T:AngouriMath.Entity.Number.Real" />
            which can be hung with others
            </summary><returns>AM's <see cref="T:AngouriMath.Entity.Number.Real" /></returns></p></li></ul></li><li><p>Method ToProvided(System.ValueTuple{AngouriMath.Entity,AngouriMath.Entity})</p><p><summary>
            Converts a tuple of an expression and its predicate to a 
            Provided node
            </summary><returns>Providedf node</returns></p></li><li><p>Method Unite(System.Collections.Generic.IEnumerable{AngouriMath.Entity.Set})</p><p><summary>
            Unites your <see cref="T:System.Collections.IEnumerable" /> into one <see cref="T:AngouriMath.Entity.Set" />.
            Applies the "or" operator on those nodes
            </summary><returns>A set of unique elements</returns></p></li></ul></p>
<!--Bottom begin-->

<br><br><br><br>
<br><br><br><br>
<br><br><br><br>
<br><br><br><br>
<br><br><br><br>
<br><br><br><br>
Angouri 2019-2021
</div>
</body>




</html>