<!doctype html>
<html lang="en">
<head>
    <title>AngouriMath</title>    
    <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon">
	<link rel="stylesheet" href="../../styles.css">
    <link rel="stylesheet" href="../../themes.css">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Overpass+Mono">
    <!-- Yandex.Metrika counter -->
<script type="text/javascript" >
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

   ym(72666283, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true
   });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/72666283" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<script src="https://buttons.github.io/buttons.js"></script>
</head>

<body>


<div class="nav-left pc">
<div class="centered nav-top">
<div>

<div class="centered">
<img class="logo pc" src="../../img/icon_cropped.png" width="120wh" height="120wh"/>
</div>

<h3>AngouriMath</h3>
<p class="slogan pc" style="color: gray">Symbolics for .NET</p>
</div>
<br>
</div>

<h5>Table of contents</h5>
<ul>
    <li><!--active_--><a href="/">Home page</a>                                              </li>
    <li><!--active_quickstart--><a href="/quickstart">Quick start</a>                                                    </li>
    <li><!--active_docs--><a href="/docs/namespaces.html">Almanac</a>                                                    </li>
    <li><!--active_whatsnew--><a href="/whatsnew">What's new</a>                                                    </li>
    <li><!--active_demo--><a href="/demo">Try online</a>                                                               </li>
    <li><!--active_why--><a href="/why">Where can be used</a>                                                                </li>
    <li><a href="https://github.com/asc-community/AngouriMath" target="_blank">GitHub repository</a>     </li>
    <li><a href="https://github.com/asc-community/AngouriMath/issues/new/choose" target="_blank">Report a bug</a></li>
    <li><a href="https://www.patreon.com/AngouriMath" target="_blank">Donate</a></li>
    <li><a href="/#contacts">Contacts</a>    </li>
</ul>

</div>

<div class="main">
<div class="head-of-page">

<!--Head of page for mobiles-->
<div class="centered phone">
<img class="logo" src="../../img/icon_cropped.png" width="100wh"/>
<h2>AngouriMath</h2>
</div>
<!--End-->

<!--For mobiles-->
<details class="phone"><summary>Navigation</summary>
<div class="centered link-block-mob">
<a href="/">Home</a>
<a href="/quickstart">Quick start</a>
<a href="/docs/namespaces.html">Almanac</a>
<a href="/whatsnew">What's new</a>
<a href="/demo">Try</a>
<a href="/why">Use</a>
<a href="https://angouri.org" target="_blank">Angouri.org</a>
<a href="https://github.com/asc-community/AngouriMath" target="_blank">GitHub</a>
<a href="https://github.com/asc-community/AngouriMath/issues/new/choose" target="_blank">Report a bug</a>
<a href="https://www.patreon.com/AngouriMath" target="_blank">Donate</a>
<a href="/#contacts">Contacts</a>
</div>
</details>
<!--End-->

</div>

<!--Top end-->

<h2 class="yadg-h2 centered">MathS</h2><hr/><p class="yadg-p "><a href="../AngouriMath.html">&#8592; Back to list of classes</a></p><h3 class="yadg-h3 ">Description</h3><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>Use functions from this class</div><h3 class="yadg-h3 ">Members</h3><p class="yadg-p "><ul class="yadg-ul "><li class="yadg-li yadg-member"><a name='Abs'></a><p class="yadg-p ">Method Abs(AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>https://en.wikipedia.org/wiki/Absolute_value</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Argument node of which Abs function will be taken</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>Abs node</div></p></li><li class="yadg-li yadg-member"><a name='Arccos'></a><p class="yadg-p ">Method Arccos(AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">https://en.wikipedia.org/wiki/Inverse_trigonometric_functions</a></div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Argument node of which arccosine will be taken</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>Arccosine node</div></p></li><li class="yadg-li yadg-member"><a name='Arccosec'></a><p class="yadg-p ">Method Arccosec(AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">https://en.wikipedia.org/wiki/Inverse_trigonometric_functions</a></div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Argument node of which arccosecant will be taken</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>Arcsine node with the reciprocal of the argument</div></p></li><li class="yadg-li yadg-member"><a name='Arccotan'></a><p class="yadg-p ">Method Arccotan(AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">https://en.wikipedia.org/wiki/Inverse_trigonometric_functions</a></div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Argument node of which arccotangent will be taken</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>Arccotangent node</div></p></li><li class="yadg-li yadg-member"><a name='Arcsec'></a><p class="yadg-p ">Method Arcsec(AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">https://en.wikipedia.org/wiki/Inverse_trigonometric_functions</a></div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Argument node of which arcsecant will be taken</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>Arccosine node with the reciprocal of the argument</div></p></li><li class="yadg-li yadg-member"><a name='Arcsin'></a><p class="yadg-p ">Method Arcsin(AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">https://en.wikipedia.org/wiki/Inverse_trigonometric_functions</a></div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Argument node of which arcsine will be taken</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>Arcsine node</div></p></li><li class="yadg-li yadg-member"><a name='Arctan'></a><p class="yadg-p ">Method Arctan(AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">https://en.wikipedia.org/wiki/Inverse_trigonometric_functions</a></div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Argument node of which arctangent will be taken</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>Arctangent node</div></p></li><li class="yadg-li yadg-member"><a name='Cbrt'></a><p class="yadg-p ">Method Cbrt(AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>Special case of <a href="https://en.wikipedia.org/wiki/Power_function">https://en.wikipedia.org/wiki/Power_function</a></div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">The argument of which cube root will be taken</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>Power node with (1/3) as the power</div></p></li><li class="yadg-li yadg-member"><a name='Conjunction'></a><p class="yadg-p ">Method Conjunction(AngouriMath.Entity,AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>https://en.wikipedia.org/wiki/Logical_conjunction</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Left argument node of which Conjunction function will be taken</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">b</strong></h4><div class="yadg-div yadg-param">Right argument node of which Conjunction disjunction function will be taken</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>And node</div></p></li><li class="yadg-li yadg-member"><a name='Cos'></a><p class="yadg-p ">Method Cos(AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Trigonometric_functions">https://en.wikipedia.org/wiki/Trigonometric_functions</a></div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Argument node of cosine</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>Cosine node</div></p></li><li class="yadg-li yadg-member"><a name='Cosec'></a><p class="yadg-p ">Method Cosec(AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Trigonometric_functions">https://en.wikipedia.org/wiki/Trigonometric_functions</a></div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Argument node of cosecant</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>Cosine node</div></p></li><li class="yadg-li yadg-member"><a name='Cotan'></a><p class="yadg-p ">Method Cotan(AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Trigonometric_functions">https://en.wikipedia.org/wiki/Trigonometric_functions</a></div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Argument node of which cotangent will be taken</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>Cotangent node</div></p></li><li class="yadg-li yadg-member"><a name='Derivative'></a><p class="yadg-p ">Method Derivative and its overloads</p><ul class="yadg-ul "><li class="yadg-li "><p class="yadg-p ">Derivative(AngouriMath.Entity,AngouriMath.Entity,System.Int32)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>
            Hangs your <a href="../AngouriMath/Entity.html">Entity</a> to a derivative node
            (to evaluate instead use <a href="../AngouriMath.MathS/Compute.html#Derivative">Derivative(AngouriMath.Entity,AngouriMath.Entity.Variable)</a>)
            </div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">expr</strong></h4><div class="yadg-div yadg-param">Expression to be hung</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">var</strong></h4><div class="yadg-div yadg-param">Variable over which derivative is taken</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">power</strong></h4><div class="yadg-div yadg-param">Number of times derivative is taken. Only integers will be simplified or evaluated.</div></p></li><li class="yadg-li "><p class="yadg-p ">Derivative(AngouriMath.Entity,AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>
            Hangs your <a href="../AngouriMath/Entity.html">Entity</a> to a derivative node
            (to evaluate instead use <a href="../AngouriMath.MathS/Compute.html#Derivative">Derivative(AngouriMath.Entity,AngouriMath.Entity.Variable)</a>)
            </div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">expr</strong></h4><div class="yadg-div yadg-param">Expression to be hung</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">var</strong></h4><div class="yadg-div yadg-param">Variable over which derivative is taken</div></p></li></ul></li><li class="yadg-li yadg-member"><a name='Disjunction'></a><p class="yadg-p ">Method Disjunction(AngouriMath.Entity,AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>https://en.wikipedia.org/wiki/Logical_disjunction</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">The left argument node of which Disjunction function will be taken</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">b</strong></h4><div class="yadg-div yadg-param">The right argument node of which Disjunction function will be taken</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>Or node</div></p></li><li class="yadg-li yadg-member"><a name='Equality'></a><p class="yadg-p ">Method Equality(AngouriMath.Entity,AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>
            Do NOT confuse it with Equation
            </div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Left argument node of which Equality function will be taken</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">b</strong></h4><div class="yadg-div yadg-param">Right argument node of which Equality disjunction function will be taken</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>An Equals node</div></p></li><li class="yadg-li yadg-member"><a name='Equations'></a><p class="yadg-p ">Method Equations and its overloads</p><ul class="yadg-ul "><li class="yadg-li "><p class="yadg-p ">Equations(AngouriMath.Entity[])</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>Use it to solve equations</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">equations</strong></h4><div class="yadg-div yadg-param">
            An array of <a href="../AngouriMath/Entity.html">Entity</a> (or <a href="../System/String.html">String</a>s)
            the system consists of
            </div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>An <a href="../AngouriMath.Core/EquationSystem.html">EquationSystem</a> which can then be solved</div></p></li><li class="yadg-li "><p class="yadg-p ">Equations(System.Collections.Generic.IEnumerable{AngouriMath.Entity})</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>Use it to solve equations</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">equations</strong></h4><div class="yadg-div yadg-param">
            An array of <a href="../AngouriMath/Entity.html">Entity</a> (or <a href="../System/String.html">String</a>s)
            the system consists of
            </div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>An <a href="../AngouriMath.Core/EquationSystem.html">EquationSystem</a> which can then be solved</div></p></li></ul></li><li class="yadg-li yadg-member"><a name='ExclusiveDisjunction'></a><p class="yadg-p ">Method ExclusiveDisjunction(AngouriMath.Entity,AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>https://en.wikipedia.org/wiki/Exclusive_or#:~:text=Exclusive%20or%20or%20exclusive%20disjunction,⊕%2C%20↮%2C%20and%20≢.</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Left argument node of which Exclusive disjunction function will be taken</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">b</strong></h4><div class="yadg-div yadg-param">Right argument node of which Exclusive disjunction function will be taken</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>Xor node</div></p></li><li class="yadg-li yadg-member"><a name='Factorial'></a><p class="yadg-p ">Method Factorial(AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Factorial">https://en.wikipedia.org/wiki/Factorial</a></div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Argument node of which factorial will be taken</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>Factorial node</div></p></li><li class="yadg-li yadg-member"><a name='FromBaseN'></a><p class="yadg-p ">Method FromBaseN(System.String,System.Int32)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>Translates a number in base <paramref name="N"/> into base 10</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">num</strong></h4><div class="yadg-div yadg-param">A <a href="../AngouriMath.Entity.Number/Real.html">Real</a> in base <paramref name="N"/> to be translated into base 10</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">N</strong></h4><div class="yadg-div yadg-param">The base to translate the number from</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>The <a href="../AngouriMath.Entity.Number/Real.html">Real</a> in base 10</div></p></li><li class="yadg-li yadg-member"><a name='FromString'></a><p class="yadg-p ">Method FromString and its overloads</p><ul class="yadg-ul "><li class="yadg-li "><p class="yadg-p ">FromString(System.String,System.Boolean)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>Converts a <a href="../System/String.html">String</a> to an expression</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">expr</strong></h4><div class="yadg-div yadg-param"><a href="../System/String.html">String</a> expression, for example, <code>"2 * x + 3 + sqrt(x)"</code></div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">useCache</strong></h4><div class="yadg-div yadg-param">By default is true, it boosts performance if you have multiple uses of the same string,
            for example, 
            Entity expr = (Entity)"+oo" + "x".Limit("x", "+oo") * "+oo";
            First occurance will be parsed, others will be replaced with the cached entity
            </div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>The parsed expression</div></p></li><li class="yadg-li "><p class="yadg-p ">FromString(System.String)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>Converts a <a href="../System/String.html">String</a> to an expression</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">expr</strong></h4><div class="yadg-div yadg-param"><a href="../System/String.html">String</a> expression, for example, <code>"2 * x + 3 + sqrt(x)"</code></div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>The parsed expression</div></p></li></ul></li><li class="yadg-li yadg-member"><a name='Gamma'></a><p class="yadg-p ">Method Gamma(AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Gamma_function">https://en.wikipedia.org/wiki/Gamma_function</a></div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Argument node of which gamma function will be taken</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>Factorial node with one added to the argument</div></p></li><li class="yadg-li yadg-member"><a name='GreaterOrEqualThan'></a><p class="yadg-p ">Method GreaterOrEqualThan(AngouriMath.Entity,AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Left argument node of which the greter than or equal node will be taken</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">b</strong></h4><div class="yadg-div yadg-param">Right argument node of which the greater than or equal node function will be taken</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>A node</div></p></li><li class="yadg-li yadg-member"><a name='GreaterThan'></a><p class="yadg-p ">Method GreaterThan(AngouriMath.Entity,AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Left argument node of which the greater than node will be taken</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">b</strong></h4><div class="yadg-div yadg-param">Right argument node of which the greater than node function will be taken</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>A node</div></p></li><li class="yadg-li yadg-member"><a name='Implication'></a><p class="yadg-p ">Method Implication(AngouriMath.Entity,AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>https://en.wikipedia.org/wiki/Material_implication_(rule_of_inference)</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">assumption</strong></h4><div class="yadg-div yadg-param">The assumption node</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">conclusion</strong></h4><div class="yadg-div yadg-param">The conclusion node</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>Implies node</div></p></li><li class="yadg-li yadg-member"><a name='Integral'></a><p class="yadg-p ">Method Integral and its overloads</p><ul class="yadg-ul "><li class="yadg-li "><p class="yadg-p ">Integral(AngouriMath.Entity,AngouriMath.Entity,System.Int32)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>
            Hangs your entity to an integral node
            (to evaluate instead use <a href="../AngouriMath.MathS/Compute.html#Integral">Integral(AngouriMath.Entity,AngouriMath.Entity.Variable)</a>)
            </div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">expr</strong></h4><div class="yadg-div yadg-param">Expression to be hung</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">var</strong></h4><div class="yadg-div yadg-param">Variable over which integral is taken</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">power</strong></h4><div class="yadg-div yadg-param">Number of times integral is taken. Only integers will be simplified or evaluated.</div></p></li><li class="yadg-li "><p class="yadg-p ">Integral(AngouriMath.Entity,AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>
            Hangs your entity to an integral node
            (to evaluate instead use <a href="../AngouriMath.MathS/Compute.html#Integral">Integral(AngouriMath.Entity,AngouriMath.Entity.Variable)</a>)
            </div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">expr</strong></h4><div class="yadg-div yadg-param">Expression to be hung</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">var</strong></h4><div class="yadg-div yadg-param">Variable over which integral is taken</div></p></li></ul></li><li class="yadg-li yadg-member"><a name='Intersection'></a><p class="yadg-p ">Method Intersection(AngouriMath.Entity,AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Left argument node of which the intersection set node will be taken</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">b</strong></h4><div class="yadg-div yadg-param">Right argument node of which the intersection set node will be taken</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>A node</div></p></li><li class="yadg-li yadg-member"><a name='Latex'></a><p class="yadg-p ">Method Latex(AngouriMath.Core.ILatexiseable)</p><p class="yadg-p "><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>
            The <a href="https://en.wikipedia.org/wiki/LaTeX">LaTeX</a> representation of the argument
            </div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">latexiseable</strong></h4><div class="yadg-div yadg-param">
            Any element (<a href="../AngouriMath/Entity.html">Entity</a>, <a href="../AngouriMath.Entity/Set.html">Set</a>, etc.) that can be represented in LaTeX
            </div></p></li><li class="yadg-li yadg-member"><a name='LessOrEqualThan'></a><p class="yadg-p ">Method LessOrEqualThan(AngouriMath.Entity,AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Left argument node of which the less than or equal node will be taken</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">b</strong></h4><div class="yadg-div yadg-param">Right argument node of which the less than or equal node function will be taken</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>A node</div></p></li><li class="yadg-li yadg-member"><a name='LessThan'></a><p class="yadg-p ">Method LessThan(AngouriMath.Entity,AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Left argument node of which the less than node will be taken</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">b</strong></h4><div class="yadg-div yadg-param">Right argument node of which the less than node function will be taken</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>A node</div></p></li><li class="yadg-li yadg-member"><a name='Limit'></a><p class="yadg-p ">Method Limit(AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Entity,AngouriMath.Core.ApproachFrom)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>
            Hangs your entity to a limit node
            (to evaluate instead use <a href="../AngouriMath.MathS/Compute.html#Limit">Limit(AngouriMath.Entity,AngouriMath.Entity.Variable,AngouriMath.Entity)</a>)
            </div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">expr</strong></h4><div class="yadg-div yadg-param">Expression to be hung</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">var</strong></h4><div class="yadg-div yadg-param">Variable over which limit is taken</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">dest</strong></h4><div class="yadg-div yadg-param">Where <paramref name="var"/> approaches (could be finite or infinite)</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">approach</strong></h4><div class="yadg-div yadg-param">From where it approaches</div></p></li><li class="yadg-li yadg-member"><a name='Ln'></a><p class="yadg-p ">Method Ln(AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>
            Is a special case of logarithm where the base equals
            <a href="https://en.wikipedia.org/wiki/E_(mathematical_constant)">e</a>:
            <a href="https://en.wikipedia.org/wiki/Natural_logarithm">https://en.wikipedia.org/wiki/Natural_logarithm</a></div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Argument node of which natural logarithm will be taken</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>Logarithm node with base equal to e</div></p></li><li class="yadg-li yadg-member"><a name='Log'></a><p class="yadg-p ">Method Log and its overloads</p><ul class="yadg-ul "><li class="yadg-li "><p class="yadg-p ">Log(AngouriMath.Entity,AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Logarithm">https://en.wikipedia.org/wiki/Logarithm</a></div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">base</strong></h4><div class="yadg-div yadg-param">Base node of logarithm</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">x</strong></h4><div class="yadg-div yadg-param">Argument node of logarithm</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>Logarithm node</div></p></li><li class="yadg-li "><p class="yadg-p ">Log(AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Logarithm">https://en.wikipedia.org/wiki/Logarithm</a></div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">x</strong></h4><div class="yadg-div yadg-param">Argument node of logarithm</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>Logarithm node</div></p></li></ul></li><li class="yadg-li yadg-member"><a name='Negation'></a><p class="yadg-p ">Method Negation(AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>https://en.wikipedia.org/wiki/Negation</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Argument node of which Negation function will be taken</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>The Not node</div></p></li><li class="yadg-li yadg-member"><a name='Piecewise'></a><p class="yadg-p ">Method Piecewise and its overloads</p><ul class="yadg-ul "><li class="yadg-li "><p class="yadg-p ">Piecewise(System.Collections.Generic.IEnumerable{AngouriMath.Entity.Providedf},AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>
            This is a piecewisely defined function, which turns into a particular definition
            once there exists a case number N such that case[N].Predicate is turned into true and
            for all i less than N : case[i].Predicate is turned into false.
            
            For example, Piecewise(new Providedf(a, b), new Providedf(d, false), new Providedf(f, true))
            will remain unchanged, because the first case is uncertain.
            
            Piecewise(new Providedf(a, false), new Providedf(d, false), new Providedf(f, true))
            will turn into f
            
            Piecewise(new Providedf(a, false), new Providedf(d, false), new Providedf(f, false))
            will turn into NaN
            </div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">cases</strong></h4><div class="yadg-div yadg-param">
            Cases, each of type Provided.
            </div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">otherwise</strong></h4><div class="yadg-div yadg-param">
            An otherwise case. Will be intepreted as otherwise.Provided(true). Optional.
            </div></p></li><li class="yadg-li "><p class="yadg-p ">Piecewise(System.ValueTuple{AngouriMath.Entity,AngouriMath.Entity}[])</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>
            This is a piecewisely defined function, which turns into a particular definition
            once there exists a case number N such that case[N].Predicate is turned into true and
            for all i less than N : case[i].Predicate is turned into false.
            
            For example, Piecewise((a, b), (d, false), (f, true))
            will remain unchanged, because the first case is uncertain.
            
            Piecewise((a, false), (d, false), (f, true))
            will turn into f
            
            Piecewise((a, false), (d, false), (f, false))
            will turn into NaN
            </div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">cases</strong></h4><div class="yadg-div yadg-param">
            Tuples of two expressions: an expression and a predicate
            </div></p></li></ul></li><li class="yadg-li yadg-member"><a name='Pow'></a><p class="yadg-p ">Method Pow(AngouriMath.Entity,AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Power_function">https://en.wikipedia.org/wiki/Power_function</a></div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">base</strong></h4><div class="yadg-div yadg-param">Base node of power</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">power</strong></h4><div class="yadg-div yadg-param">Argument node of power</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>Power node</div></p></li><li class="yadg-li yadg-member"><a name='Provided'></a><p class="yadg-p ">Method Provided(AngouriMath.Entity,AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>
            This will be turned into <paramref name="expression"/> if the <paramref name="condition"/> is true,
            into NaN if <paramref name="condition"/> is false, and remain the same otherwise
            </div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">expression</strong></h4><div class="yadg-div yadg-param">The expression is extracted if the predicate is true</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">condition</strong></h4><div class="yadg-div yadg-param">Condition when the expression is defined</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>The Provided node</div></p></li><li class="yadg-li yadg-member"><a name='Sec'></a><p class="yadg-p ">Method Sec(AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Trigonometric_functions">https://en.wikipedia.org/wiki/Trigonometric_functions</a></div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Argument node of secant</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>Cosine node</div></p></li><li class="yadg-li yadg-member"><a name='SetSubtraction'></a><p class="yadg-p ">Method SetSubtraction(AngouriMath.Entity,AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">
            Left argument node of which the set subtraction node will be taken
            That is, the resulting set of set subtraction is necessarily superset of this set
            </div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">b</strong></h4><div class="yadg-div yadg-param">
            Right argument node of which the set subtraction set node will be taken
            That is, there is no element in the resulting set that belong to this one
            </div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>A node</div></p></li><li class="yadg-li yadg-member"><a name='Signum'></a><p class="yadg-p ">Method Signum(AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>https://en.wikipedia.org/wiki/Sign_function</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Argument node of which Signum function will be taken</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>Signum node</div></p></li><li class="yadg-li yadg-member"><a name='Sin'></a><p class="yadg-p ">Method Sin(AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Trigonometric_functions">https://en.wikipedia.org/wiki/Trigonometric_functions</a></div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Argument node of sine</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>Sine node</div></p></li><li class="yadg-li yadg-member"><a name='SolveBooleanTable'></a><p class="yadg-p ">Method SolveBooleanTable(AngouriMath.Entity,AngouriMath.Entity.Variable[])</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>
            Solves a boolean expression. That is, finds all values for
            <paramref name="variables"/> such that the expression turns into True when evaluated
            Uses a simple table of truth
            Use <a href="../AngouriMath/Entity.html#SolveBoolean">SolveBoolean(AngouriMath.Entity.Variable)</a> for smart solving
            </div></p></li><li class="yadg-li yadg-member"><a name='SolveEquation'></a><p class="yadg-p ">Method SolveEquation(AngouriMath.Entity,AngouriMath.Entity.Variable)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>Solves one equation over one variable</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">equation</strong></h4><div class="yadg-div yadg-param">An equation that is assumed to equal 0</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">var</strong></h4><div class="yadg-div yadg-param">Variable whose values we are looking for</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>A <a href="../AngouriMath.Entity/Set.html">Set</a> of possible values or intervals of values</div></p></li><li class="yadg-li yadg-member"><a name='Sqr'></a><p class="yadg-p ">Method Sqr(AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>Special case of <a href="https://en.wikipedia.org/wiki/Power_function">https://en.wikipedia.org/wiki/Power_function</a></div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Argument to be squared</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>Power node with 2 as the power</div></p></li><li class="yadg-li yadg-member"><a name='Sqrt'></a><p class="yadg-p ">Method Sqrt(AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>Special case of <a href="https://en.wikipedia.org/wiki/Power_function">https://en.wikipedia.org/wiki/Power_function</a></div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">The argument of which square root will be taken</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>Power node with (1/2) as the power</div></p></li><li class="yadg-li yadg-member"><a name='Tan'></a><p class="yadg-p ">Method Tan(AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Trigonometric_functions">https://en.wikipedia.org/wiki/Trigonometric_functions</a></div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Argument node of which tangent will be taken</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>Tangent node</div></p></li><li class="yadg-li yadg-member"><a name='ToBaseN'></a><p class="yadg-p ">Method ToBaseN(AngouriMath.Entity.Number.Real,System.Int32)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>Translates a <a href="../AngouriMath.Entity/Number.html">Number</a> in base 10 into base <paramref name="N"/></div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">num</strong></h4><div class="yadg-div yadg-param">A <a href="../AngouriMath.Entity.Number/Real.html">Real</a> in base 10 to be translated into base <paramref name="N"/></div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">N</strong></h4><div class="yadg-div yadg-param">The base to translate the number into</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>A <a href="../System/String.html">String</a> with the number in the required base</div></p></li><li class="yadg-li yadg-member"><a name='ToSympyCode'></a><p class="yadg-p ">Method ToSympyCode(AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>sympy interpretable format</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">expr</strong></h4><div class="yadg-div yadg-param">An <a href="../AngouriMath/Entity.html">Entity</a> representing an expression</div></p></li><li class="yadg-li yadg-member"><a name='TryPolynomial'></a><p class="yadg-p ">Method TryPolynomial(AngouriMath.Entity,AngouriMath.Entity.Variable,AngouriMath.Entity@)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>Returns an <a href="../AngouriMath/Entity.html">Entity</a> in polynomial order if possible</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">expr</strong></h4><div class="yadg-div yadg-param">The unordered <a href="../AngouriMath/Entity.html">Entity</a></div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">variable</strong></h4><div class="yadg-div yadg-param">The variable of the polynomial</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">dst</strong></h4><div class="yadg-div yadg-param">The ordered result</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'><see langword="true"/> if success,
            <see langword="false"/> otherwise (<paramref name="dst"/> will be <see langword="null"/>)
            </div></p></li><li class="yadg-li yadg-member"><a name='Union'></a><p class="yadg-p ">Method Union(AngouriMath.Entity,AngouriMath.Entity)</p><p class="yadg-p "><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">a</strong></h4><div class="yadg-div yadg-param">Left argument node of which the union set node will be taken</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">b</strong></h4><div class="yadg-div yadg-param">Right argument node of which the union set node will be taken</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>A node</div></p></li><li class="yadg-li yadg-member"><a name='Var'></a><p class="yadg-p ">Method Var(System.String)</p><p class="yadg-p "><h4 class="yadg-h4 ">Summary</h4><div class='yadg-summary'>Creates an instance of <a href="../AngouriMath.Entity/Variable.html">Variable</a>.</div><h4 class="yadg-h4 ">Parameter <strong class="yadg-strong ">name</strong></h4><div class="yadg-div yadg-param">The name of the <a href="../AngouriMath.Entity/Variable.html">Variable</a> which equality is based on.</div><h4 class="yadg-h4 ">Returns</h4><div class='yadg-returns'>Variable node</div></p></li></ul></p>
<!--Bottom begin-->

<br><br><br><br>
<br><br><br><br>
<br><br><br><br>
<br><br><br><br>
<br><br><br><br>
<br><br><br><br>
Angouri 2019-2021
</div>
</body>




</html>