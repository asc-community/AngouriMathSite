<!doctype html>
<html lang="en">
<head>
    <title>AngouriMath</title>    
    <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon">
	<link rel="stylesheet" href="../../styles.css">
    <link rel="stylesheet" href="../../themes.css">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Overpass+Mono">
    <!-- Yandex.Metrika counter -->
<script type="text/javascript" >
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

   ym(72666283, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true
   });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/72666283" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<script src="https://buttons.github.io/buttons.js"></script>
</head>

<body>


<div class="nav-left pc">
<div class="centered nav-top">
<div>

<div class="centered">
<img class="logo pc" src="../../img/icon_cropped.png" width="120wh" height="120wh"/>
</div>

<h3>AngouriMath</h3>
<p class="slogan pc" style="color: gray">Symbolics for .NET</p>
</div>
<br>
</div>

<h5>Table of contents</h5>
<ul>
    <li><!--active_--><a href="/">Home page</a>                                              </li>
    <li><!--active_quickstart--><a href="/quickstart">Quick start</a>                                                    </li>
    <li><!--active_docs--><a href="/docs/namespaces.html">Documentation</a>                                                    </li>
    <li><!--active_whatsnew--><a href="/whatsnew">What's new</a>                                                    </li>
    <li><!--active_demo--><a href="/demo">Try online</a>                                                               </li>
    <li><!--active_why--><a href="/why">Where can be used</a>                                                                </li>
    <li><a href="https://github.com/asc-community/AngouriMath" target="_blank">GitHub repository</a>     </li>
    <li><a href="https://github.com/asc-community/AngouriMath/issues/new/choose" target="_blank">Report a bug</a></li>
    <li><a href="https://www.patreon.com/AngouriMath" target="_blank">Donate</a></li>
    <li><a href="/#contacts">Contacts</a>    </li>
</ul>

</div>

<div class="main">
<div class="head-of-page">

<!--Head of page for mobiles-->
<div class="centered phone">
<img class="logo" src="../../img/icon_cropped.png" width="100wh"/>
<h2>AngouriMath</h2>
</div>
<!--End-->

<!--For mobiles-->
<details class="phone"><summary>Navigation</summary>
<div class="centered link-block-mob">
<a href="/">Home</a>
<a href="/quickstart">Quick start</a>
<a href="/docs/namespaces.html">Documentation</a>
<a href="/whatsnew">What's new</a>
<a href="/demo">Try</a>
<a href="/why">Use</a>
<a href="https://angouri.org" target="_blank">Angouri.org</a>
<a href="https://github.com/asc-community/AngouriMath" target="_blank">GitHub</a>
<a href="https://github.com/asc-community/AngouriMath/issues/new/choose" target="_blank">Report a bug</a>
<a href="https://www.patreon.com/AngouriMath" target="_blank">Donate</a>
<a href="/#contacts">Contacts</a>
</div>
</details>
<!--End-->

</div>

<!--Top end-->

<h2 class="centered">MathS</h2><hr/><p><a href="../AngouriMath.html"><< Back to list of classes</a></p><p>Let us see all the members of the class or record MathS</p><p><ul><li><p>Method AngouriMath.MathS.Arccos(AngouriMath.Entity)</p><p><summary><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions" /></summary><param name="a">Argument node of which arccosine will be taken</param><returns>Arccosine node</returns></p></li><li><p>Method AngouriMath.MathS.Arccosec(AngouriMath.Entity)</p><p><summary><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions" /></summary><param name="a">Argument node of which arccosecant will be taken</param><returns>Arcsine node with the reciprocal of the argument</returns></p></li><li><p>Method AngouriMath.MathS.Arccotan(AngouriMath.Entity)</p><p><summary><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions" /></summary><param name="a">Argument node of which arccotangent will be taken</param><returns>Arccotangent node</returns></p></li><li><p>Method AngouriMath.MathS.Cos(AngouriMath.Entity)</p><p><summary><a href="https://en.wikipedia.org/wiki/Trigonometric_functions" /></summary><param name="a">Argument node of cosine</param><returns>Cosine node</returns></p></li><li><p>Method AngouriMath.MathS.Cosec(AngouriMath.Entity)</p><p><summary><a href="https://en.wikipedia.org/wiki/Trigonometric_functions" /></summary><param name="a">Argument node of cosecant</param><returns>Cosine node</returns></p></li><li><p>Method AngouriMath.MathS.Cotan(AngouriMath.Entity)</p><p><summary><a href="https://en.wikipedia.org/wiki/Trigonometric_functions" /></summary><param name="a">Argument node of which cotangent will be taken</param><returns>Cotangent node</returns></p></li><li><p>Method AngouriMath.MathS.Derivative(AngouriMath.Entity,AngouriMath.Entity,System.Int32)</p><p><summary>
            Hangs your <see cref="T:AngouriMath.Entity" /> to a derivative node
            (to evaluate instead use <see cref="M:AngouriMath.MathS.Compute.Derivative(AngouriMath.Entity,AngouriMath.Entity.Variable)" />)
            </summary><param name="expr">Expression to be hung</param><param name="var">Variable over which derivative is taken</param><param name="power">Number of times derivative is taken. Only integers will be simplified or evaluated.</param></p></li><li><p>Method AngouriMath.MathS.Disjunction(AngouriMath.Entity,AngouriMath.Entity)</p><p><summary>https://en.wikipedia.org/wiki/Logical_disjunction</summary><param name="a">The left argument node of which Disjunction function will be taken</param><param name="b">The right argument node of which Disjunction function will be taken</param><returns>Or node</returns></p></li><li><p>Method AngouriMath.MathS.Equality(AngouriMath.Entity,AngouriMath.Entity)</p><p><summary>
            Do NOT confuse it with Equation
            </summary><param name="a">Left argument node of which Equality function will be taken</param><param name="b">Right argument node of which Equality disjunction function will be taken</param><returns>An Equals node</returns></p></li><li><p>Method AngouriMath.MathS.Equations(System.Collections.Generic.IEnumerable{AngouriMath.Entity})</p><p><summary>Use it to solve equations</summary><param name="equations">
            An array of <see cref="T:AngouriMath.Entity" /> (or <see cref="T:System.String" />s)
            the system consists of
            </param><returns>An <see cref="T:AngouriMath.Core.EquationSystem" /> which can then be solved</returns></p></li><li><p>Method AngouriMath.MathS.Factorial(AngouriMath.Entity)</p><p><summary><a href="https://en.wikipedia.org/wiki/Factorial" /></summary><param name="a">Argument node of which factorial will be taken</param><returns>Factorial node</returns></p></li><li><p>Method AngouriMath.MathS.FromBaseN(System.String,System.Int32)</p><p><summary>Translates a number in base <paramref name="N" /> into base 10</summary><param name="num">A <see cref="T:AngouriMath.Entity.Number.Real" /> in base <paramref name="N" /> to be translated into base 10</param><param name="N">The base to translate the number from</param><returns>The <see cref="T:AngouriMath.Entity.Number.Real" /> in base 10</returns></p></li><li><p>Method AngouriMath.MathS.FromString(System.String)</p><p><summary>Converts a <see cref="T:System.String" /> to an expression</summary><param name="expr"><see cref="T:System.String" /> expression, for example, <code>"2 * x + 3 + sqrt(x)"</code></param><returns>The parsed expression</returns></p></li><li><p>Method AngouriMath.MathS.Implication(AngouriMath.Entity,AngouriMath.Entity)</p><p><summary>https://en.wikipedia.org/wiki/Material_implication_(rule_of_inference)</summary><param name="assumption">The assumption node</param><param name="conclusion">The conclusion node</param><returns>Implies node</returns></p></li><li><p>Method AngouriMath.MathS.Integral(AngouriMath.Entity,AngouriMath.Entity,System.Int32)</p><p><summary>
            Hangs your entity to an integral node
            (to evaluate instead use <see cref="M:AngouriMath.MathS.Compute.Integral(AngouriMath.Entity,AngouriMath.Entity.Variable)" />)
            </summary><param name="expr">Expression to be hung</param><param name="var">Variable over which integral is taken</param><param name="power">Number of times integral is taken. Only integers will be simplified or evaluated.</param></p></li><li><p>Method AngouriMath.MathS.Intersection(AngouriMath.Entity,AngouriMath.Entity)</p><p><param name="a">Left argument node of which the intersection set node will be taken</param><param name="b">Right argument node of which the intersection set node will be taken</param><returns>A node</returns></p></li><li><p>Method AngouriMath.MathS.LessOrEqualThan(AngouriMath.Entity,AngouriMath.Entity)</p><p><param name="a">Left argument node of which the less than or equal node will be taken</param><param name="b">Right argument node of which the less than or equal node function will be taken</param><returns>A node</returns></p></li><li><p>Method AngouriMath.MathS.LessThan(AngouriMath.Entity,AngouriMath.Entity)</p><p><param name="a">Left argument node of which the less than node will be taken</param><param name="b">Right argument node of which the less than node function will be taken</param><returns>A node</returns></p></li><li><p>Method AngouriMath.MathS.Log(AngouriMath.Entity)</p><p><summary><a href="https://en.wikipedia.org/wiki/Logarithm" /></summary><param name="x">Argument node of logarithm</param><returns>Logarithm node</returns></p></li><li><p>Method AngouriMath.MathS.Negation(AngouriMath.Entity)</p><p><summary>https://en.wikipedia.org/wiki/Negation</summary><param name="a">Argument node of which Negation function will be taken</param><returns>The Not node</returns></p></li><li><p>Method AngouriMath.MathS.Piecewise(System.Collections.Generic.IEnumerable{AngouriMath.Entity.Providedf},AngouriMath.Entity)</p><p><summary>
            This is a piecewisely defined function, which turns into a particular definition
            once there exists a case number N such that case[N].Predicate is turned into true and
            for all i less than N : case[i].Predicate is turned into false.
            
            For example, Piecewise(new Providedf(a, b), new Providedf(d, false), new Providedf(f, true))
            will remain unchanged, because the first case is uncertain.
            
            Piecewise(new Providedf(a, false), new Providedf(d, false), new Providedf(f, true))
            will turn into f
            
            Piecewise(new Providedf(a, false), new Providedf(d, false), new Providedf(f, false))
            will turn into NaN
            </summary><param name="cases">
            Cases, each of type Provided.
            </param><param name="otherwise">
            An otherwise case. Will be intepreted as otherwise.Provided(true). Optional.
            </param></p></li><li><p>Method AngouriMath.MathS.Signum(AngouriMath.Entity)</p><p><summary>https://en.wikipedia.org/wiki/Sign_function</summary><param name="a">Argument node of which Signum function will be taken</param><returns>Signum node</returns></p></li><li><p>Method AngouriMath.MathS.SolveBooleanTable(AngouriMath.Entity,AngouriMath.Entity.Variable[])</p><p><summary>
            Solves a boolean expression. That is, finds all values for
            <paramref name="variables" /> such that the expression turns into True when evaluated
            Uses a simple table of truth
            Use <see cref="M:AngouriMath.Entity.SolveBoolean(AngouriMath.Entity.Variable)" /> for smart solving
            </summary></p></li><li><p>Method AngouriMath.MathS.Sqr(AngouriMath.Entity)</p><p><summary>Special case of <a href="https://en.wikipedia.org/wiki/Power_function" /></summary><param name="a">Argument to be squared</param><returns>Power node with 2 as the power</returns></p></li><li><p>Method AngouriMath.MathS.Sqrt(AngouriMath.Entity)</p><p><summary>Special case of <a href="https://en.wikipedia.org/wiki/Power_function" /></summary><param name="a">The argument of which square root will be taken</param><returns>Power node with (1/2) as the power</returns></p></li><li><p>Method AngouriMath.MathS.ToSympyCode(AngouriMath.Entity)</p><p><returns>sympy interpretable format</returns><param name="expr">An <see cref="T:AngouriMath.Entity" /> representing an expression</param></p></li><li><p>Method AngouriMath.MathS.Var(System.String)</p><p><summary>Creates an instance of <see cref="T:AngouriMath.Entity.Variable" />.</summary><param name="name">The name of the <see cref="T:AngouriMath.Entity.Variable" /> which equality is based on.</param><returns>Variable node</returns></p></li></ul></p>
<!--Bottom begin-->

<br><br><br><br>
<br><br><br><br>
<br><br><br><br>
<br><br><br><br>
<br><br><br><br>
<br><br><br><br>
Angouri 2019-2021
</div>
</body>




</html>