<!doctype html>
<html lang="en">
<head>
    <title>AngouriMath</title>    
    <link rel="shortcut icon" href="/img/favicon.ico" type="image/x-icon">
	<link rel="stylesheet" href="../../styles.css">
    <link rel="stylesheet" href="../../themes.css">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Overpass+Mono">
    <!-- Yandex.Metrika counter -->
<script type="text/javascript" >
   (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
   m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)})
   (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym");

   ym(72666283, "init", {
        clickmap:true,
        trackLinks:true,
        accurateTrackBounce:true
   });
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/72666283" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
<!-- /Yandex.Metrika counter -->

<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<script src="https://buttons.github.io/buttons.js"></script>

<script src="https://code.iconify.design/1/1.0.7/iconify.min.js"></script>
</head>

<body>


<div class="nav-left pc">
<div class="centered nav-top">
<div>

<div class="centered">
<img class="logo pc" src="../../img/icon_cropped.png" width="120wh" height="120wh"/>
</div>

<h3>AngouriMath</h3>
<p class="slogan pc" style="color: gray">Symbolics for .NET</p>
</div>
<br>
</div>

<h5>Table of contents</h5>
<ul class='table-of-contents'>
    <li><!--active_-->          <span class="iconify" data-icon="octicon:home-16" data-inline="true"></span><a href="/" alt="Main page with all key points">Home page</a>                                              </li>
    <li><!--active_quickstart--><span class="iconify" data-icon="octicon:zap-16" data-inline="true"></span><a href="/quickstart">Quick start</a>                                                    </li>
    <li><!--active_wiki-->      <span class="iconify" data-icon="octicon:book-16" data-inline="true"></span><a href="/wiki">Wiki</a>                                                               </li>
    <li class="active-link">      <span class="iconify" data-icon="octicon:database-16" data-inline="true"></span><a href="/docs/namespaces.html">Almanac</a>                                                    </li>
    <li><!--active_whatsnew-->  <span class="iconify" data-icon="octicon:flame-16" data-inline="true"></span><a href="/whatsnew">What's new</a>                                                    </li>
    <li><!--active_demo-->      <span class="iconify" data-icon="octicon:code-review-16" data-inline="true"></span><a href="/demo">Try online</a>                                                               </li>
    <li><span class="iconify" data-icon="octicon:mark-github-16" data-inline="true"></span><a href="https://github.com/asc-community/AngouriMath" target="_blank">GitHub</a>     </li>
    <li><span class="iconify" data-icon="octicon:bug-16" data-inline="true"></span><a href="https://github.com/asc-community/AngouriMath/issues/new/choose" target="_blank">Report a bug</a></li>
    <li><span class="iconify" data-icon="octicon:heart-16" data-inline="true"></span><a href="https://www.patreon.com/AngouriMath" target="_blank">Donate</a></li>
    <li><span class="iconify" data-icon="octicon:comment-discussion-16" data-inline="true"></span><a href="/#contacts">Contacts</a>    </li>
</ul>

</div>

<div class="main">
<div class="head-of-page">

<!--Head of page for mobiles-->
<div class="centered phone">
<img class="logo" src="../../img/icon_cropped.png" width="100wh"/>
<h2>AngouriMath</h2>
</div>
<!--End-->

<!--For mobiles-->
<details class="phone"><summary>Navigation</summary>
<div class="centered link-block-mob">
<a href="/">Home</a>
<a href="/quickstart">Quick start</a>
<a href="/wiki">Wiki</a>
<a href="/docs/namespaces.html">Almanac</a>
<a href="/whatsnew">What's new</a>
<a href="/demo">Try</a>
<a href="/why">Use</a>
<a href="https://angouri.org" target="_blank">Angouri.org</a>
<a href="https://github.com/asc-community/AngouriMath" target="_blank">GitHub</a>
<a href="https://github.com/asc-community/AngouriMath/issues/new/choose" target="_blank">Report a bug</a>
<a href="https://www.patreon.com/AngouriMath" target="_blank">Donate</a>
<a href="/#contacts">Contacts</a>
</div>
</details>
<!--End-->

</div>

<!--Top end-->

<h2 class="yadg-h2 centered">MathS</h2><hr/><p class="yadg-p "><a href="../AngouriMath.html">&#8592; Back to list of classes</a></p><h2 class="yadg-h2 ">Description</h2><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Use functions from this class</div><h2 class="yadg-h2 ">Members</h2><p class="yadg-p "><ul class="yadg-ul "><li class="yadg-li yadg-member yadg-list"><a name='Abs'></a><p class="yadg-p "><h3 class="yadg-h3 ">Abs (AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>https://en.wikipedia.org/wiki/Absolute_value</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which Abs function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Abs node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Arccos'></a><p class="yadg-p "><h3 class="yadg-h3 ">Arccos (AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">https://en.wikipedia.org/wiki/Inverse_trigonometric_functions</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which arccosine will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Arccosine node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Arccosec'></a><p class="yadg-p "><h3 class="yadg-h3 ">Arccosec (AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">https://en.wikipedia.org/wiki/Inverse_trigonometric_functions</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which arccosecant will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Arcsine node with the reciprocal of the argument</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Arccotan'></a><p class="yadg-p "><h3 class="yadg-h3 ">Arccotan (AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">https://en.wikipedia.org/wiki/Inverse_trigonometric_functions</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which arccotangent will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Arccotangent node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Arcsec'></a><p class="yadg-p "><h3 class="yadg-h3 ">Arcsec (AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">https://en.wikipedia.org/wiki/Inverse_trigonometric_functions</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which arcsecant will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Arccosine node with the reciprocal of the argument</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Arcsin'></a><p class="yadg-p "><h3 class="yadg-h3 ">Arcsin (AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">https://en.wikipedia.org/wiki/Inverse_trigonometric_functions</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which arcsine will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Arcsine node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Arctan'></a><p class="yadg-p "><h3 class="yadg-h3 ">Arctan (AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">https://en.wikipedia.org/wiki/Inverse_trigonometric_functions</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which arctangent will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Arctangent node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Cbrt'></a><p class="yadg-p "><h3 class="yadg-h3 ">Cbrt (AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Special case of <a href="https://en.wikipedia.org/wiki/Power_function">https://en.wikipedia.org/wiki/Power_function</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">The argument of which cube root will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Power node with (1/3) as the power</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Conjunction'></a><p class="yadg-p "><h3 class="yadg-h3 ">Conjunction (AngouriMath. Entity, AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>https://en.wikipedia.org/wiki/Logical_conjunction</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Left argument node of which Conjunction function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "b"</strong></p><div class="yadg-div yadg-param">Right argument node of which Conjunction disjunction function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>And node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Cos'></a><p class="yadg-p "><h3 class="yadg-h3 ">Cos (AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Trigonometric_functions">https://en.wikipedia.org/wiki/Trigonometric_functions</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of cosine</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Cosine node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Cosec'></a><p class="yadg-p "><h3 class="yadg-h3 ">Cosec (AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Trigonometric_functions">https://en.wikipedia.org/wiki/Trigonometric_functions</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of cosecant</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Cosine node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Cotan'></a><p class="yadg-p "><h3 class="yadg-h3 ">Cotan (AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Trigonometric_functions">https://en.wikipedia.org/wiki/Trigonometric_functions</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which cotangent will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Cotangent node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Derivative'></a><p class="yadg-p "><h3 class="yadg-h3 ">Derivative</h3> Method and its overloads</p><ul class="yadg-ul "><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">Derivative (AngouriMath. Entity, AngouriMath. Entity, System. Int32)</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Hangs your <a href="../AngouriMath/Entity.html">Entity</a> to a derivative node<br>            (to evaluate instead use <a href="../AngouriMath.MathS/Compute.html#Derivative">Derivative(AngouriMath.Entity,AngouriMath.Entity.Variable)</a>)<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Parameter "expr"</strong></p><div class="yadg-div yadg-param">Expression to be hung</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "var"</strong></p><div class="yadg-div yadg-param">Variable over which derivative is taken</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "power"</strong></p><div class="yadg-div yadg-param">Number of times derivative is taken. Only integers will be simplified or evaluated.</div></p></li><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">Derivative (AngouriMath. Entity, AngouriMath. Entity)</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Hangs your <a href="../AngouriMath/Entity.html">Entity</a> to a derivative node<br>            (to evaluate instead use <a href="../AngouriMath.MathS/Compute.html#Derivative">Derivative(AngouriMath.Entity,AngouriMath.Entity.Variable)</a>)<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Parameter "expr"</strong></p><div class="yadg-div yadg-param">Expression to be hung</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "var"</strong></p><div class="yadg-div yadg-param">Variable over which derivative is taken</div></p></li></ul></li><li class="yadg-li yadg-member yadg-list"><a name='Det'></a><p class="yadg-p "><h3 class="yadg-h3 ">Det (AngouriMath. Entity. Matrix)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Finds the determinant of the given matrix. If<br>            the matrix is non-square, returns null<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Disjunction'></a><p class="yadg-p "><h3 class="yadg-h3 ">Disjunction (AngouriMath. Entity, AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>https://en.wikipedia.org/wiki/Logical_disjunction</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">The left argument node of which Disjunction function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "b"</strong></p><div class="yadg-div yadg-param">The right argument node of which Disjunction function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Or node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='e'></a><p class="yadg-p "><h3 class="yadg-h3 ">e</h3> Field</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            The e constant<br>            <a href="https://en.wikipedia.org/wiki/E_(mathematical_constant)">https://en.wikipedia.org/wiki/E_(mathematical_constant)</a></div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Equality'></a><p class="yadg-p "><h3 class="yadg-h3 ">Equality (AngouriMath. Entity, AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Do NOT confuse it with Equation<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Left argument node of which Equality function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "b"</strong></p><div class="yadg-div yadg-param">Right argument node of which Equality disjunction function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>An Equals node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Equations'></a><p class="yadg-p "><h3 class="yadg-h3 ">Equations</h3> Method and its overloads</p><ul class="yadg-ul "><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">Equations (AngouriMath. Entity[])</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Use it to solve equations</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "equations"</strong></p><div class="yadg-div yadg-param">            An array of <a href="../AngouriMath/Entity.html">Entity</a> (or Strings)<br>            the system consists of<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>An EquationSystem which can then be solved</div></p></li><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">Equations (System. Collections. Generic. IEnumerable{AngouriMath. Entity})</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Use it to solve equations</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "equations"</strong></p><div class="yadg-div yadg-param">            An array of <a href="../AngouriMath/Entity.html">Entity</a> (or Strings)<br>            the system consists of<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>An EquationSystem which can then be solved</div></p></li></ul></li><li class="yadg-li yadg-member yadg-list"><a name='ExclusiveDisjunction'></a><p class="yadg-p "><h3 class="yadg-h3 ">ExclusiveDisjunction (AngouriMath. Entity, AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>https://en.wikipedia.org/wiki/Exclusive_or</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Left argument node of which Exclusive disjunction function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "b"</strong></p><div class="yadg-div yadg-param">Right argument node of which Exclusive disjunction function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Xor node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Factorial'></a><p class="yadg-p "><h3 class="yadg-h3 ">Factorial (AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Factorial">https://en.wikipedia.org/wiki/Factorial</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which factorial will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Factorial node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='FromBaseN'></a><p class="yadg-p "><h3 class="yadg-h3 ">FromBaseN (System. String, System. Int32)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Translates a number in base <text class="yadg-text cw">N</text> into base 10</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "num"</strong></p><div class="yadg-div yadg-param">A <a href="../AngouriMath.Entity.Number/Real.html">Real</a> in base <text class="yadg-text cw">N</text> to be translated into base 10</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "N"</strong></p><div class="yadg-div yadg-param">The base to translate the number from</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>The <a href="../AngouriMath.Entity.Number/Real.html">Real</a> in base 10</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='FromString'></a><p class="yadg-p "><h3 class="yadg-h3 ">FromString</h3> Method and its overloads</p><ul class="yadg-ul "><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">FromString (System. String, System. Boolean)</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Converts a String to an expression</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "expr"</strong></p><div class="yadg-div yadg-param">String expression, for example, <pre><code>"2 * x + 3 + sqrt(x)"</code></pre></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "useCache"</strong></p><div class="yadg-div yadg-param">By default is true, it boosts performance if you have multiple uses of the same string,<br>            for example, <br>            Entity expr = (Entity)"+oo" + "x".Limit("x", "+oo") * "+oo";<br>            First occurance will be parsed, others will be replaced with the cached entity<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>The parsed expression</div></p></li><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">FromString (System. String)</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Converts a String to an expression</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "expr"</strong></p><div class="yadg-div yadg-param">String expression, for example, <pre><code>"2 * x + 3 + sqrt(x)"</code></pre></div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>The parsed expression</div></p></li></ul></li><li class="yadg-li yadg-member yadg-list"><a name='Gamma'></a><p class="yadg-p "><h3 class="yadg-h3 ">Gamma (AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Gamma_function">https://en.wikipedia.org/wiki/Gamma_function</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which gamma function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Factorial node with one added to the argument</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='GreaterOrEqualThan'></a><p class="yadg-p "><h3 class="yadg-h3 ">GreaterOrEqualThan (AngouriMath. Entity, AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Left argument node of which the greter than or equal node will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "b"</strong></p><div class="yadg-div yadg-param">Right argument node of which the greater than or equal node function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>A node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='GreaterThan'></a><p class="yadg-p "><h3 class="yadg-h3 ">GreaterThan (AngouriMath. Entity, AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Left argument node of which the greater than node will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "b"</strong></p><div class="yadg-div yadg-param">Right argument node of which the greater than node function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>A node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='i'></a><p class="yadg-p "><h3 class="yadg-h3 ">i</h3> Field</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            The imaginary one<br>            <a href="https://en.wikipedia.org/wiki/Imaginary_unit">https://en.wikipedia.org/wiki/Imaginary_unit</a></div></p></li><li class="yadg-li yadg-member yadg-list"><a name='I_1'></a><p class="yadg-p "><h3 class="yadg-h3 ">I_1</h3> Field</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            The square identity matrix of size 1<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='I_2'></a><p class="yadg-p "><h3 class="yadg-h3 ">I_2</h3> Field</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            The square identity matrix of size 2<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='I_3'></a><p class="yadg-p "><h3 class="yadg-h3 ">I_3</h3> Field</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            The square identity matrix of size 3<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='I_4'></a><p class="yadg-p "><h3 class="yadg-h3 ">I_4</h3> Field</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            The square identity matrix of size 4<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='IdentityMatrix'></a><p class="yadg-p "><h3 class="yadg-h3 ">IdentityMatrix</h3> Method and its overloads</p><ul class="yadg-ul "><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">IdentityMatrix (System. Int32, System. Int32)</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Creates a rectangular identity matrix<br>            with the given size<br>            </div></p></li><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">IdentityMatrix (System. Int32)</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Creates a square identity matrix<br>            </div></p></li></ul></li><li class="yadg-li yadg-member yadg-list"><a name='Implication'></a><p class="yadg-p "><h3 class="yadg-h3 ">Implication (AngouriMath. Entity, AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>https://en.wikipedia.org/wiki/Material_implication_(rule_of_inference)</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "assumption"</strong></p><div class="yadg-div yadg-param">The assumption node</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "conclusion"</strong></p><div class="yadg-div yadg-param">The conclusion node</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Implies node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Integral'></a><p class="yadg-p "><h3 class="yadg-h3 ">Integral</h3> Method and its overloads</p><ul class="yadg-ul "><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">Integral (AngouriMath. Entity, AngouriMath. Entity, System. Int32)</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Hangs your entity to an integral node<br>            (to evaluate instead use <a href="../AngouriMath.MathS/Compute.html#Integral">Integral(AngouriMath.Entity,AngouriMath.Entity.Variable)</a>)<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Parameter "expr"</strong></p><div class="yadg-div yadg-param">Expression to be hung</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "var"</strong></p><div class="yadg-div yadg-param">Variable over which integral is taken</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "power"</strong></p><div class="yadg-div yadg-param">Number of times integral is taken. Only integers will be simplified or evaluated.</div></p></li><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">Integral (AngouriMath. Entity, AngouriMath. Entity)</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Hangs your entity to an integral node<br>            (to evaluate instead use <a href="../AngouriMath.MathS/Compute.html#Integral">Integral(AngouriMath.Entity,AngouriMath.Entity.Variable)</a>)<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Parameter "expr"</strong></p><div class="yadg-div yadg-param">Expression to be hung</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "var"</strong></p><div class="yadg-div yadg-param">Variable over which integral is taken</div></p></li></ul></li><li class="yadg-li yadg-member yadg-list"><a name='Intersection'></a><p class="yadg-p "><h3 class="yadg-h3 ">Intersection (AngouriMath. Entity, AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Left argument node of which the intersection set node will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "b"</strong></p><div class="yadg-div yadg-param">Right argument node of which the intersection set node will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>A node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Interval'></a><p class="yadg-p "><h3 class="yadg-h3 ">Interval</h3> Method and its overloads</p><ul class="yadg-ul "><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">Interval (AngouriMath. Entity, AngouriMath. Entity)</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Creates a closed interval (segment)<br>            </div></p></li><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">Interval (AngouriMath. Entity, System. Boolean, AngouriMath. Entity, System. Boolean)</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Creates an interval with custom endings<br>            </div></p></li></ul></li><li class="yadg-li yadg-member yadg-list"><a name='Latex'></a><p class="yadg-p "><h3 class="yadg-h3 ">Latex (AngouriMath. Core. ILatexiseable)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>            The <a href="https://en.wikipedia.org/wiki/LaTeX">LaTeX</a> representation of the argument<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Parameter "latexiseable"</strong></p><div class="yadg-div yadg-param">            Any element (<a href="../AngouriMath/Entity.html">Entity</a>, <a href="../AngouriMath.Entity/Set.html">Set</a>, etc.) that can be represented in LaTeX<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='LessOrEqualThan'></a><p class="yadg-p "><h3 class="yadg-h3 ">LessOrEqualThan (AngouriMath. Entity, AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Left argument node of which the less than or equal node will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "b"</strong></p><div class="yadg-div yadg-param">Right argument node of which the less than or equal node function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>A node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='LessThan'></a><p class="yadg-p "><h3 class="yadg-h3 ">LessThan (AngouriMath. Entity, AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Left argument node of which the less than node will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "b"</strong></p><div class="yadg-div yadg-param">Right argument node of which the less than node function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>A node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Limit'></a><p class="yadg-p "><h3 class="yadg-h3 ">Limit (AngouriMath. Entity, AngouriMath. Entity, AngouriMath. Entity, AngouriMath. Core. ApproachFrom)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Hangs your entity to a limit node<br>            (to evaluate instead use <a href="../AngouriMath.MathS/Compute.html#Limit">Limit(AngouriMath.Entity,AngouriMath.Entity.Variable,AngouriMath.Entity)</a>)<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Parameter "expr"</strong></p><div class="yadg-div yadg-param">Expression to be hung</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "var"</strong></p><div class="yadg-div yadg-param">Variable over which limit is taken</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "dest"</strong></p><div class="yadg-div yadg-param">Where <text class="yadg-text cw">var</text> approaches (could be finite or infinite)</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "approach"</strong></p><div class="yadg-div yadg-param">From where it approaches</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Ln'></a><p class="yadg-p "><h3 class="yadg-h3 ">Ln (AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Is a special case of logarithm where the base equals<br>            <a href="https://en.wikipedia.org/wiki/E_(mathematical_constant)">e</a>:<br>            <a href="https://en.wikipedia.org/wiki/Natural_logarithm">https://en.wikipedia.org/wiki/Natural_logarithm</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which natural logarithm will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Logarithm node with base equal to e</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Log'></a><p class="yadg-p "><h3 class="yadg-h3 ">Log</h3> Method and its overloads</p><ul class="yadg-ul "><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">Log (AngouriMath. Entity, AngouriMath. Entity)</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Logarithm">https://en.wikipedia.org/wiki/Logarithm</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "base"</strong></p><div class="yadg-div yadg-param">Base node of logarithm</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "x"</strong></p><div class="yadg-div yadg-param">Argument node of logarithm</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Logarithm node</div></p></li><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">Log (AngouriMath. Entity)</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Logarithm">https://en.wikipedia.org/wiki/Logarithm</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "x"</strong></p><div class="yadg-div yadg-param">Argument node of logarithm</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Logarithm node</div></p></li></ul></li><li class="yadg-li yadg-member yadg-list"><a name='Matrix'></a><p class="yadg-p "><h3 class="yadg-h3 ">Matrix</h3> Method and its overloads</p><ul class="yadg-ul "><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">Matrix (AngouriMath. Entity[0:, 0:])</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Creates an instance of <a href="../AngouriMath.Entity/Matrix.html">Matrix</a>.</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "values"</strong></p><div class="yadg-div yadg-param">            A two-dimensional array of values.<br>            The first dimension is the row count, the second one is for columns.<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>A two-dimensional <a href="../AngouriMath.Entity/Matrix.html">Matrix</a> which is a matrix</div></p></li><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">Matrix (System. Int32, System. Int32, System. Func{System. Int32, System. Int32, AngouriMath. Entity})</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Creates an instance of matrix, where each cell's<br>            index is mapped to a value with the help of the<br>            mapping function.<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Parameter "rowCount"</strong></p><div class="yadg-div yadg-param">            The number of rows (corresponds to the first index).<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Parameter "colCount"</strong></p><div class="yadg-div yadg-param">            The number of columns (corresponds to the second index).<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Parameter "map"</strong></p><div class="yadg-div yadg-param">            The first argument of the mapping function<br>            function is the index of row, the second one for the <br>            column index.<br>            <br>            Indexing starts from 0.<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>            A newly created matrix of the given size.<br>            </div></p></li></ul></li><li class="yadg-li yadg-member yadg-list"><a name='MatrixFromIEnum2x2'></a><p class="yadg-p "><h3 class="yadg-h3 ">MatrixFromIEnum2x2 (System. Collections. Generic. IEnumerable{System. Collections. Generic. IEnumerable{AngouriMath. Entity}})</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Creates a matrix from given elements<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Parameter "elements"</strong></p><div class="yadg-div yadg-param">            There should be at least one row.<br>            All rows must have the same number<br>            of columns<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='MatrixFromRows'></a><p class="yadg-p "><h3 class="yadg-h3 ">MatrixFromRows (System. Collections. Generic. IEnumerable{AngouriMath. Entity. Matrix})</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Creates a matrix from given rows<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Parameter "vectors"</strong></p><div class="yadg-div yadg-param">            There should be at least one row.<br>            All rows must have the same number<br>            of columns<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='NaN'></a><p class="yadg-p "><h3 class="yadg-h3 ">NaN</h3> Field</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            That is both undefined and indeterminite<br>            Any operation on NaN returns NaN<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Negation'></a><p class="yadg-p "><h3 class="yadg-h3 ">Negation (AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>https://en.wikipedia.org/wiki/Negation</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which Negation function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>The Not node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='O_1'></a><p class="yadg-p "><h3 class="yadg-h3 ">O_1</h3> Field</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            The square zero matrix of size 1<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='O_2'></a><p class="yadg-p "><h3 class="yadg-h3 ">O_2</h3> Field</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            The square zero matrix of size 2<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='O_3'></a><p class="yadg-p "><h3 class="yadg-h3 ">O_3</h3> Field</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            The square zero matrix of size 3<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='O_4'></a><p class="yadg-p "><h3 class="yadg-h3 ">O_4</h3> Field</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            The square zero matrix of size 4<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Parse'></a><p class="yadg-p "><h3 class="yadg-h3 ">Parse (System. String)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Parses an expression silently, that is,<br>            without throwing an exception. Instead,<br>            it returns a Failure in case of encountered<br>            errors during parsing.<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>            Returns a type union of the successful result and<br>            failure, which is a type union of multiple reasons<br>            it may have failed.<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='pi'></a><p class="yadg-p "><h3 class="yadg-h3 ">pi</h3> Field</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            The pi constant<br>            <a href="https://en.wikipedia.org/wiki/Pi">https://en.wikipedia.org/wiki/Pi</a></div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Piecewise'></a><p class="yadg-p "><h3 class="yadg-h3 ">Piecewise</h3> Method and its overloads</p><ul class="yadg-ul "><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">Piecewise (System. Collections. Generic. IEnumerable{AngouriMath. Entity. Providedf}, AngouriMath. Entity)</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            This is a piecewisely defined function, which turns into a particular definition<br>            once there exists a case number N such that case[N].Predicate is turned into true and<br>            for all i less than N : case[i].Predicate is turned into false.<br>            <br>            For example, Piecewise(new Providedf(a, b), new Providedf(d, false), new Providedf(f, true))<br>            will remain unchanged, because the first case is uncertain.<br>            <br>            Piecewise(new Providedf(a, false), new Providedf(d, false), new Providedf(f, true))<br>            will turn into f<br>            <br>            Piecewise(new Providedf(a, false), new Providedf(d, false), new Providedf(f, false))<br>            will turn into NaN<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Parameter "cases"</strong></p><div class="yadg-div yadg-param">            Cases, each of type Provided.<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Parameter "otherwise"</strong></p><div class="yadg-div yadg-param">            An otherwise case. Will be intepreted as otherwise.Provided(true). Optional.<br>            </div></p></li><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">Piecewise (System. ValueTuple{AngouriMath. Entity, AngouriMath. Entity}[])</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            This is a piecewisely defined function, which turns into a particular definition<br>            once there exists a case number N such that case[N].Predicate is turned into true and<br>            for all i less than N : case[i].Predicate is turned into false.<br>            <br>            For example, Piecewise((a, b), (d, false), (f, true))<br>            will remain unchanged, because the first case is uncertain.<br>            <br>            Piecewise((a, false), (d, false), (f, true))<br>            will turn into f<br>            <br>            Piecewise((a, false), (d, false), (f, false))<br>            will turn into NaN<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Parameter "cases"</strong></p><div class="yadg-div yadg-param">            Tuples of two expressions: an expression and a predicate<br>            </div></p></li></ul></li><li class="yadg-li yadg-member yadg-list"><a name='Pow'></a><p class="yadg-p "><h3 class="yadg-h3 ">Pow (AngouriMath. Entity, AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Power_function">https://en.wikipedia.org/wiki/Power_function</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "base"</strong></p><div class="yadg-div yadg-param">Base node of power</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "power"</strong></p><div class="yadg-div yadg-param">Argument node of power</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Power node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Provided'></a><p class="yadg-p "><h3 class="yadg-h3 ">Provided (AngouriMath. Entity, AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            This will be turned into <text class="yadg-text cw">expression</text> if the <text class="yadg-text cw">condition</text> is true,<br>            into NaN if <text class="yadg-text cw">condition</text> is false, and remain the same otherwise<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Parameter "expression"</strong></p><div class="yadg-div yadg-param">The expression is extracted if the predicate is true</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "condition"</strong></p><div class="yadg-div yadg-param">Condition when the expression is defined</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>The Provided node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Scalar'></a><p class="yadg-p "><h3 class="yadg-h3 ">Scalar (AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Creates a 1x1 matrix of a given value. It will be simplified<br>            once InnerSimplified or Evaled are addressed<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>            A 1x1 matrix, which is also a 1-long vector, or just a scalar.<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Sec'></a><p class="yadg-p "><h3 class="yadg-h3 ">Sec (AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Trigonometric_functions">https://en.wikipedia.org/wiki/Trigonometric_functions</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of secant</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Cosine node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='SetSubtraction'></a><p class="yadg-p "><h3 class="yadg-h3 ">SetSubtraction (AngouriMath. Entity, AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">            Left argument node of which the set subtraction node will be taken<br>            That is, the resulting set of set subtraction is necessarily superset of this set<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Parameter "b"</strong></p><div class="yadg-div yadg-param">            Right argument node of which the set subtraction set node will be taken<br>            That is, there is no element in the resulting set that belong to this one<br>            </div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>A node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Signum'></a><p class="yadg-p "><h3 class="yadg-h3 ">Signum (AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>https://en.wikipedia.org/wiki/Sign_function</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which Signum function will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Signum node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Sin'></a><p class="yadg-p "><h3 class="yadg-h3 ">Sin (AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Trigonometric_functions">https://en.wikipedia.org/wiki/Trigonometric_functions</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of sine</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Sine node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='SolveBooleanTable'></a><p class="yadg-p "><h3 class="yadg-h3 ">SolveBooleanTable (AngouriMath. Entity, AngouriMath. Entity. Variable[])</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Solves a boolean expression. That is, finds all values for<br>            <text class="yadg-text cw">variables</text> such that the expression turns into True when evaluated<br>            Uses a simple table of truth<br>            Use <a href="../AngouriMath/Entity.html#SolveBoolean">SolveBoolean(AngouriMath.Entity.Variable)</a> for smart solving<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='SolveEquation'></a><p class="yadg-p "><h3 class="yadg-h3 ">SolveEquation (AngouriMath. Entity, AngouriMath. Entity. Variable)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Solves one equation over one variable</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "equation"</strong></p><div class="yadg-div yadg-param">An equation that is assumed to equal 0</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "var"</strong></p><div class="yadg-div yadg-param">Variable whose values we are looking for</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>A <a href="../AngouriMath.Entity/Set.html">Set</a> of possible values or intervals of values</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Sqr'></a><p class="yadg-p "><h3 class="yadg-h3 ">Sqr (AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Special case of <a href="https://en.wikipedia.org/wiki/Power_function">https://en.wikipedia.org/wiki/Power_function</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument to be squared</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Power node with 2 as the power</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Sqrt'></a><p class="yadg-p "><h3 class="yadg-h3 ">Sqrt (AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Special case of <a href="https://en.wikipedia.org/wiki/Power_function">https://en.wikipedia.org/wiki/Power_function</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">The argument of which square root will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Power node with (1/2) as the power</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Tan'></a><p class="yadg-p "><h3 class="yadg-h3 ">Tan (AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'><a href="https://en.wikipedia.org/wiki/Trigonometric_functions">https://en.wikipedia.org/wiki/Trigonometric_functions</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Argument node of which tangent will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Tangent node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='ToBaseN'></a><p class="yadg-p "><h3 class="yadg-h3 ">ToBaseN (AngouriMath. Entity. Number. Real, System. Int32)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Translates a <a href="../AngouriMath.Entity/Number.html">Number</a> in base 10 into base <text class="yadg-text cw">N</text></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "num"</strong></p><div class="yadg-div yadg-param">A <a href="../AngouriMath.Entity.Number/Real.html">Real</a> in base 10 to be translated into base <text class="yadg-text cw">N</text></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "N"</strong></p><div class="yadg-div yadg-param">The base to translate the number into</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>A String with the number in the required base</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='ToSympyCode'></a><p class="yadg-p "><h3 class="yadg-h3 ">ToSympyCode (AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>sympy interpretable format</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "expr"</strong></p><div class="yadg-div yadg-param">An <a href="../AngouriMath/Entity.html">Entity</a> representing an expression</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='TryPolynomial'></a><p class="yadg-p "><h3 class="yadg-h3 ">TryPolynomial (AngouriMath. Entity, AngouriMath. Entity. Variable, AngouriMath. Entity@)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Returns an <a href="../AngouriMath/Entity.html">Entity</a> in polynomial order if possible</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "expr"</strong></p><div class="yadg-div yadg-param">The unordered <a href="../AngouriMath/Entity.html">Entity</a></div><p class="yadg-p "><strong class="yadg-strong ">Parameter "variable"</strong></p><div class="yadg-div yadg-param">The variable of the polynomial</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "dst"</strong></p><div class="yadg-div yadg-param">The ordered result</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'><text class="yadg-text cw">true</text> if success,<br>            <text class="yadg-text cw">false</text> otherwise (<text class="yadg-text cw">dst</text> will be <text class="yadg-text cw">null</text>)<br>            </div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Union'></a><p class="yadg-p "><h3 class="yadg-h3 ">Union (AngouriMath. Entity, AngouriMath. Entity)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Parameter "a"</strong></p><div class="yadg-div yadg-param">Left argument node of which the union set node will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "b"</strong></p><div class="yadg-div yadg-param">Right argument node of which the union set node will be taken</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>A node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Var'></a><p class="yadg-p "><h3 class="yadg-h3 ">Var (System. String)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Creates an instance of <a href="../AngouriMath.Entity/Variable.html">Variable</a>.</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "name"</strong></p><div class="yadg-div yadg-param">The name of the <a href="../AngouriMath.Entity/Variable.html">Variable</a> which equality is based on.</div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>Variable node</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='Vector'></a><p class="yadg-p "><h3 class="yadg-h3 ">Vector (AngouriMath. Entity[])</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>Creates an instance of <a href="../AngouriMath.Entity/Matrix.html">Matrix</a> that has one column.</div><p class="yadg-p "><strong class="yadg-strong ">Parameter "values"</strong></p><div class="yadg-div yadg-param">The cells of the <a href="../AngouriMath.Entity/Matrix.html">Matrix</a></div><p class="yadg-p "><strong class="yadg-strong ">Returns</strong></p><div class='yadg-returns'>A one-dimensional <a href="../AngouriMath.Entity/Matrix.html">Matrix</a> which is a vector</div></p></li><li class="yadg-li yadg-member yadg-list"><a name='ZeroMatrix'></a><p class="yadg-p "><h3 class="yadg-h3 ">ZeroMatrix</h3> Method and its overloads</p><ul class="yadg-ul "><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">ZeroMatrix (System. Int32, System. Int32)</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Creates a zero square matrix<br>            </div></p></li><li class="yadg-li yadg-list-2"><h3 class="yadg-h3 ">ZeroMatrix (System. Int32)</h3><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Creates a zero square matrix<br>            </div></p></li></ul></li><li class="yadg-li yadg-member yadg-list"><a name='ZeroVector'></a><p class="yadg-p "><h3 class="yadg-h3 ">ZeroVector (System. Int32)</h3> Method</p><p class="yadg-p "><p class="yadg-p "><strong class="yadg-strong ">Summary</strong></p><div class='yadg-summary'>            Creates a zero vector<br>            </div></p></li></ul></p>
<!--Bottom begin-->

<br><br><br><br>
<br><br><br><br>
<br><br><br><br>
<br><br><br><br>
<br><br><br><br>
<br><br><br><br>
2019-2021 <a href="https://angouri.org">Angouri</a> &middot; 
<a href="https://github.com/asc-community/AngouriMath">Project's repo</a> &middot; 
<a href="https://github.com/asc-community/AngouriMathSite">Site's repo</a> &middot; 
<a href="https://iconify.design/icon-sets/octicon/" target="_blank">Octicons</a>
</div>
</body>




</html>